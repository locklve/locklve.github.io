<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Signal&amp;System Conclusion Chapter06-08</title>
      <link href="/2024/12/11/Signal&amp;System/Signal-System-Chapter06/"/>
      <url>/2024/12/11/Signal&amp;System/Signal-System-Chapter06/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统-chapter-04-05-09-10-总结归纳"><a href="#信号与系统-chapter-04-05-09-10-总结归纳" class="headerlink" title="信号与系统 chapter 04-05 &amp; 09-10 总结归纳"></a>信号与系统 chapter 04-05 &amp; 09-10 总结归纳</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>在上一篇博客中，我们讲述了连续时间下的傅里叶变换以及对应的更为一般的情况，拉普拉斯变换。以及这两个变换在线性时不变系统中的表征和性质。其次我们讲述了离散时间下的傅里叶变换以及对应的更为一般的情况，Z变换。以及这两个变换在线性时不变系统中的表征和性质。无论是拉普拉斯变换还是Z变换都是对原输入信号添加一个增益后再进行傅里叶变换，为了满足添加增益后的输入信号能够收敛，我们对增益有一定的限制，由此引出了拉普拉斯变换和Z变换的收敛域的概念。</p><p>下面我们将开始介绍Chapter 06-08的内容，这也是我们最后的一部分内容。</p><h2 id="Chapter-06"><a href="#Chapter-06" class="headerlink" title="Chapter 06"></a>Chapter 06</h2><h3 id="幅度与相位表征系统函数"><a href="#幅度与相位表征系统函数" class="headerlink" title="幅度与相位表征系统函数"></a>幅度与相位表征系统函数</h3><p>在前文中，我们说线性时不变系统对于一个复指数信号的响应是等于信号自身乘上一个系统函数，对应的输入输出的傅里叶变换有$Y(s) &#x3D; X(s)H(s)$,对于$H(s)$来说，既有幅度的信息，也有相位的信息，即我们可以将系统函数写成相量的形式，$ \lvert H(s) \rvert \arg(H(s)) $。同理，除了连续时间以外，对于离散时间的系统函数同样可以写成幅度与相位之间的组合形式，即$Y(e^{j\omega}) &#x3D; X(e^{j\omega})H(e^{j\omega})$。</p><p>于是根据幅度与相位的关系，我们可以得到以下两个式子：</p><p>$$ \lvert Y(j\omega) \rvert &#x3D; \lvert X(j\omega) \rvert \lvert H(j\omega) \rvert  , \arg(Y(j\omega)) &#x3D; \arg(X(j\omega)) + \arg(H(j\omega)) $$</p><p>可以指出的是，当系统函数表现为某个增益和线性相位时，对应的输出就是输入的一个时延。若系统函数是一个非线性的相位，常见的就是相位是与$\omega$相关的函数，这种情况下输出不仅是输入的一个时延，输出自身的序列也会发生改变，较为常见的便是<strong>群时延</strong>。群时延准确来说就是$\arg(H(j\omega)) &#x3D; -\phi-\omega \alpha$的一个系统函数，具有的是非线性的相位特性，其中的$\alpha$不是固定不变的时延$t_{0}$，而是一个与$\omega$的取值有关，不同的频率对应有不同的时延，与我们前面所讲一个信号可以表示为一系列成谐波关系的复指数信号集相对应，我们不同谐波通过系统后的时延也不相同，导致输出变形。</p><h3 id="伯德图表示系统函数"><a href="#伯德图表示系统函数" class="headerlink" title="伯德图表示系统函数"></a>伯德图表示系统函数</h3><p>对于系统函数，我们可以通过伯德图分别画出其幅度响应特征曲线和相位响应特征曲线。需要注意的是，连续时间的系统函数是非周期的，而离散时间的系统函数是周期函数。</p><p>我们一般对系统函数取log，分别表征其幅度与相位。</p><p><img src="/img/signal-system/Chapter6-bode-plot.png" alt="Bode plot"></p><p>将系统函数取log并乘上20后，当取某一个$\omega$值时，我们可以得到-3dB，那么我们称此时的频率为转折频率。</p><h2 id="Chapter-08"><a href="#Chapter-08" class="headerlink" title="Chapter 08"></a>Chapter 08</h2><h3 id="AM-调制"><a href="#AM-调制" class="headerlink" title="AM 调制"></a>AM 调制</h3><p>AM调制，即幅度调制，就是将调制信号的波形（幅度信息）调制到载波信号上，现在我们假设有一个调制信号和一个载波信号$ mod &#x3D; Amp * \sin(2\pi f_{m}t) , carrier &#x3D; Amp * \sin(2\pi f_{c}t) $。通过下面的公式进行AM调制即：</p><p>$$ AM_{signal} &#x3D; (A + mod) * carrier &#x3D; (A + Amp*\sin(2\pi f_{m}t)) * \sin(2\pi f_{c}t) $$</p><p>其中，比值$\frac{max{mod}}{A} &#x3D; \frac{Amp}{A}$称为调制深度，当比值为1时，调制深度为$100%$；当比值为0.5时，调制深度为$50%$，由此类推。信号的波形如图:</p><p><img src="/img/signal-system/Chapter8-AM-Mod.png" alt="AM mod"></p><p>那么我们接收到了这样的一个信号我们应该如何解调出我们想要的信号呢？方法一，相干解调。具体公式推导如下：</p><p>$$ y(t) &#x3D; AM_{signal} * carrier &#x3D; (A + Amp<em>\sin(2\pi f_{m}t)) * \sin(2\pi f_{c}t) * \sin(2\pi f_{c}t) $$<br>$$ &#x3D; (A + Amp</em>\sin(2\pi f_{m}t)) * \frac{1}{2}(1 - \cos(2\pi 2f_{c}t)) $$<br>$$ &#x3D; \frac{1}{2}(A + Amp*\sin(2\pi f_{m}t)) - \frac{A}{2}\cos(2\pi 2f_{c}t) - \frac{Amp}{2}\sin(2\pi f_{m}t)\cos(2\pi 2f_{c}t) $$</p><p>可以观察发现，后两项的频率显著高于前两项，于是我们将相乘后的信号通过低通滤波器滤去高频信号，就可以得到我们想要的信号。只需要再去除里面的直流分量，同时提供一个幅度为2的增益，这样就可以得到我们调制的信号。</p><p>方法二，包络检波。详见下图：</p><p><img src="/img/signal-system/Chapter8-AM-DeMod.png" alt="AM Demod"></p><p>为了防止概念过于抽象，这里提供MATLAB的仿真代码，可以较为形象的理解AM调制与解调的过程。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">Fs = <span class="number">4e6</span>;       <span class="comment">% 采样频率,根据采样定理，采样频率要大于最高频率的两倍</span></span><br><span class="line">Fc = <span class="number">2e5</span>;       <span class="comment">% 载波频率</span></span><br><span class="line">Fm = <span class="number">4e3</span>;       <span class="comment">% 调制信号频率</span></span><br><span class="line">Am = <span class="number">1</span>;         <span class="comment">% 载波幅度 -&gt; 叠加在调制信号的直流偏置</span></span><br><span class="line">ma = <span class="number">1</span>;         <span class="comment">% 调幅指数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建时间轴</span></span><br><span class="line">L = <span class="number">8e3</span>;        <span class="comment">% 取样点数</span></span><br><span class="line">Ts = <span class="number">1</span> / Fs;    <span class="comment">% 采样周期</span></span><br><span class="line">t = (<span class="number">1</span> : L ) * Ts;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成AM信号</span></span><br><span class="line"><span class="comment">% 创建载波信号 正弦载波</span></span><br><span class="line">carr_w = Am * <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*Fc*t);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, carr_w);</span><br><span class="line">title(<span class="string">&#x27;carr_w&#x27;</span>);</span><br><span class="line"><span class="comment">% 创建调制信号（这里使用一个简单的正弦波作为调制信号）</span></span><br><span class="line">modu_s = Am*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*Fm*t);    <span class="comment">% Am * ma is the Amp of modu_s</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, modu_s);</span><br><span class="line">title(<span class="string">&#x27;modu_s&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行调幅</span></span><br><span class="line">AM_signal = ((ma + modu_s) .* <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*Fc*t));</span><br><span class="line"><span class="comment">% AM_signal = (modu_s .* sin(2*pi*Fc*t));</span></span><br><span class="line"><span class="comment">% if Am is not enough to enlarge modu_s to all over 0 -&gt; over-modulation</span></span><br><span class="line">[ST_I,f_I] = my_fft(AM_signal,Fs);  <span class="comment">% 观察已调信号st的频谱</span></span><br><span class="line"><span class="comment">% 解调AM信号</span></span><br><span class="line">AM_mid = AM_signal .* carr_w;</span><br><span class="line">output = lowpass(AM_mid, Fm*<span class="number">2</span>, Fs);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, output);</span><br><span class="line">title(<span class="string">&#x27;demodu_s with DC&#x27;</span>);</span><br><span class="line">out_fix = output-<span class="built_in">mean</span>(output);  <span class="comment">% 去除直流分量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制解调后的波形</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, AM_signal);</span><br><span class="line">title(<span class="string">&#x27;AM调制波&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, <span class="number">2</span>*out_fix);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,modu_s,<span class="string">&#x27;r-&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t, output,<span class="string">&#x27;r--&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;解调信号&#x27;</span>,<span class="string">&#x27;调制信号&#x27;</span>,<span class="string">&#x27;未去除直流分量的解调信号&#x27;</span>)</span><br><span class="line"><span class="comment">% 计算调制指数</span></span><br><span class="line">Amax = <span class="built_in">max</span>((output(L/<span class="number">8</span>:<span class="number">7</span>*L/<span class="number">8</span>)));</span><br><span class="line">Amin = <span class="built_in">min</span>((output(L/<span class="number">8</span>:<span class="number">7</span>*L/<span class="number">8</span>)));</span><br><span class="line">ma = (Amax - Amin) / (Amax + Amin);</span><br><span class="line">fprintf(<span class="string">&#x27;调制指数 ma = %.2f\n&#x27;</span>, ma);</span><br><span class="line"><span class="comment">% 观察频谱 不提供FFT函数 可以直接使用MATLAB自带的FFT函数操作</span></span><br><span class="line">[ST_O,f_O] = my_fft(out_fix,Fs);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(f_O,<span class="built_in">abs</span>(ST_O));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅度&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;解调信号频谱图&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(f_I,<span class="built_in">abs</span>(ST_I));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅度&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;已调信号频谱图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;解调信号&#x27;</span>,<span class="string">&#x27;AM信号&#x27;</span>);</span><br><span class="line">[~, max_index] = <span class="built_in">max</span>(ST_O);</span><br><span class="line">fre=<span class="built_in">abs</span>(f_O(max_index));</span><br><span class="line">fprintf(<span class="string">&#x27;基带频率 fre = %.2f\n&#x27;</span>,fre );</span><br></pre></td></tr></table></figure><h3 id="FM-调制-和-PM-调制"><a href="#FM-调制-和-PM-调制" class="headerlink" title="FM 调制 和 PM 调制"></a>FM 调制 和 PM 调制</h3><p>首先我们先给出FM调制的表达式：</p><p>$$ FM_{signal}(t) &#x3D; A\cos((\omega_{c}+k_{f}x(t))t + \theta_{c}) $$</p><p>这个表明FM调制，就是将调制信号调制到载波信号上，调制后的信号的频率由调制信号控制。与之极其相似的是PM调制的表达式，详见如下：</p><p>$$PM_{signal}(t) &#x3D; A \cos(2\pi f_c t + \theta_{c} + 2\pi k_f x(t)) $$</p><p>很显然，一个是调制信号控制调制后信号的频率，一个是调制信号控制调制后信号的相位，即$x(t)$出现的位置不一样。但是由于相位等价于频率的积分$\theta &#x3D; \int \omega(t) dt$，所以两者之间有时候很难区分。如果说将FM调制的式子展开，就能够发现与PM调制表达式一致，只是用于控制相位的不是调制信号，而是调制信号与时间t的乘积——$k_{f}x(t) * t$。</p><p>两种不同调制方式的效果图如下：</p><p><img src="/img/signal-system/Chapter8-FMPM-Mod.png" alt="FM PM"></p><p>对应的MATLAB仿真代码如下：</p><ul><li><p>首先是FM调制，其中还包含了雷达通信使用的线性调制。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% FM调制解调过程</span></span><br><span class="line">clc;clear;</span><br><span class="line"><span class="comment">% 基本参数</span></span><br><span class="line">fm = <span class="number">1e2</span>;                   <span class="comment">% 基带信号频率 -&gt; modulation signal</span></span><br><span class="line">T = <span class="number">5</span>;                      <span class="comment">% 信号时长</span></span><br><span class="line">fs = <span class="number">2e4</span>;                   <span class="comment">% 采样频率 奈奎斯特采样定理为最大频率的两倍，这里取20倍为了绘制更多的细节，让时域信号更平滑</span></span><br><span class="line">dt=<span class="number">1</span>/fs;                    <span class="comment">% 时间采样间隔，采样频率的倒数</span></span><br><span class="line">N=T/dt;                     <span class="comment">% 采样点个数，总时长除以采样间隔</span></span><br><span class="line">t = (<span class="number">0</span> : N<span class="number">-1</span>) * dt;         <span class="comment">% 采样点的时间序列，作为横坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% *********Modulated Signal in Time domain*******</span></span><br><span class="line">Am = <span class="number">1</span>;                             <span class="comment">% 基带信号幅度 </span></span><br><span class="line">modu_s = Am*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fm*t);         <span class="comment">% 基带信号</span></span><br><span class="line"><span class="built_in">figure</span>;                             <span class="comment">% 绘制第一幅图</span></span><br><span class="line"><span class="built_in">plot</span>(t,modu_s);                     <span class="comment">% 时间t为横坐标，基带信号mt为纵坐标绘图，线宽为2</span></span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);                     <span class="comment">% 横坐标标注</span></span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);                      <span class="comment">% 纵坐标标注</span></span><br><span class="line">title(<span class="string">&#x27;Base signal&#x27;</span>);               <span class="comment">% 图标题标注</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.1</span> <span class="number">-1.1</span> <span class="number">1.1</span>]);             <span class="comment">% 横纵坐标范围设置</span></span><br><span class="line"><span class="comment">% 绘制一条从(0,0)到(0.1,0)的蓝色实线，线宽为2</span></span><br><span class="line">line([<span class="number">0</span>,<span class="number">0.1</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;Linewidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% *****Modulated Signal in Frequency domain*****</span></span><br><span class="line">[mf, msf] = T2F(t, modu_s);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(mf, <span class="built_in">abs</span>(msf));</span><br><span class="line">title(<span class="string">&#x27;Modu_s in Freq domain&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency Hz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp H&#x27;</span>);</span><br><span class="line">axis([<span class="number">-250</span> <span class="number">250</span> <span class="number">0</span> <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% *****Carrier Signal in Time domain*******</span></span><br><span class="line">fc = <span class="number">1e3</span>;</span><br><span class="line">A = <span class="number">1</span>;</span><br><span class="line">carrier_wave = A * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, carrier_wave);</span><br><span class="line">title(<span class="string">&#x27;carrier wave&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.01</span> <span class="number">-1.1</span> <span class="number">1.1</span>]);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0.01</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;Linewidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ******carrier signal in Frequency domain******</span></span><br><span class="line">[cf, csf] = T2F(t, carrier_wave);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(cf, <span class="built_in">abs</span>(csf));</span><br><span class="line">title(<span class="string">&#x27;carrier signal in freq&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f Hz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp H&#x27;</span>);</span><br><span class="line">axis([<span class="number">-1200</span> <span class="number">1200</span> <span class="number">0</span> <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FM</span></span><br><span class="line">Ksfm = <span class="number">4e3</span>;     <span class="comment">% influence </span></span><br><span class="line">SFM = A * <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*t + (Ksfm*Am)/(<span class="number">2</span>*<span class="built_in">pi</span>*fm).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fm*t) + <span class="built_in">pi</span>);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, SFM, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Frequency Modulation&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.1</span> <span class="number">-1.2</span> <span class="number">1.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">% Linear Frequency modulate</span></span><br><span class="line">Ksfm1 = <span class="number">1e5</span>;</span><br><span class="line">SFM1 = A * <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*t + <span class="built_in">pi</span>*Ksfm1*t.^<span class="number">2</span>);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, <span class="built_in">real</span>(SFM1), <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Frequency Modulation&#x27;</span>);</span><br><span class="line">axis([<span class="number">0.03</span> <span class="number">0.08</span> <span class="number">-1.2</span> <span class="number">1.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N<span class="number">-1</span></span><br><span class="line">    diff_SFM(<span class="built_in">i</span>) = (SFM(<span class="built_in">i</span> + <span class="number">1</span>) - SFM(<span class="built_in">i</span>)) / dt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">diff_SFM = <span class="built_in">abs</span>(hilbert(diff_SFM));</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">1</span>:N<span class="number">-1</span>) * dt, diff_SFM);</span><br><span class="line">title(<span class="string">&#x27;envelope with DC&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.1</span> <span class="number">1000</span> <span class="number">11000</span>]);</span><br><span class="line">line([<span class="number">0</span>, <span class="number">0.1</span>], [<span class="number">0</span>, <span class="number">0</span>], <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">demodu_s = (diff_SFM / A - <span class="number">2</span>*<span class="built_in">pi</span>*fc)/Ksfm;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>((<span class="number">1</span>:N<span class="number">-1</span>) * dt, demodu_s);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t, modu_s, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;envelope and raw&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amp&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.1</span> <span class="number">-1.2</span> <span class="number">1.2</span>]);</span><br><span class="line">line([<span class="number">0</span>, <span class="number">0.1</span>], [<span class="number">0</span>, <span class="number">0</span>], <span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>其次是相位调制和解调，你会发现解调的效果不好这是因为相位承载了信号大部分的信息，相位调制本质上将信号的相位信息破坏了，所以解调的效果一般。</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% PM调制解调</span></span><br><span class="line"><span class="comment">% Demonstrate simple Phase Demodulation using Hilbert transform</span></span><br><span class="line"></span><br><span class="line">clear; clc;</span><br><span class="line">fc = <span class="number">210</span>;           <span class="comment">% carrier frequency</span></span><br><span class="line">fm = <span class="number">10</span>;            <span class="comment">% frequency of modulating signal</span></span><br><span class="line">alpha = <span class="number">1</span>;          <span class="comment">% amplitude of modulating signal</span></span><br><span class="line">theta = <span class="built_in">pi</span>/<span class="number">4</span>;       <span class="comment">% phase offset of modulating signal</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="built_in">pi</span>/<span class="number">5</span>;        <span class="comment">% constant carrier phase offset</span></span><br><span class="line">receiverKnowsCarrier= <span class="string">&#x27;False&#x27;</span>;</span><br><span class="line"><span class="comment">% Set True if receiver knows carrier frequency &amp; phase offset</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">8</span>*fc;                  <span class="comment">% sampling frequency</span></span><br><span class="line">duration = <span class="number">0.5</span>;             <span class="comment">% duration of the signal</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">1</span>/fs:duration<span class="number">-1</span>/fs;   <span class="comment">% time base</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Phase Modulation</span></span><br><span class="line">m_t = alpha*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fm*t + theta);     <span class="comment">% modulating signal</span></span><br><span class="line">phi_t = <span class="number">2</span>*<span class="built_in">pi</span>*fc*t + <span class="built_in">beta</span> + m_t;</span><br><span class="line">x = <span class="built_in">cos</span>(phi_t);                         <span class="comment">% modulated signal</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t,m_t);                            <span class="comment">% plot modulating signal</span></span><br><span class="line">title(<span class="string">&#x27;Modulating signal&#x27;</span>); </span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>); ylabel(<span class="string">&#x27;m(t)&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t,x);                              <span class="comment">% plot modulated signal</span></span><br><span class="line">title(<span class="string">&#x27;Modulated signal&#x27;</span>); </span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>);ylabel(<span class="string">&#x27;x(t)&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.3</span> <span class="number">-1.1</span> <span class="number">1.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% %Add AWGN noise to the transmitted signal</span></span><br><span class="line"><span class="comment">% nMean = 0; nSigma = 0.1; %noise mean and sigma</span></span><br><span class="line"><span class="comment">% n = nMean + nSigma*randn(size(t)); %awgn noise</span></span><br><span class="line"><span class="comment">% r = x + n; %noisy received signal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Demodulation of the noisy Phase Modulated signal</span></span><br><span class="line">z = hilbert(x);                 <span class="comment">% form the analytical signal from the received vector</span></span><br><span class="line">inst_phase = <span class="built_in">unwrap</span>(<span class="built_in">angle</span>(z));  <span class="comment">% instaneous phase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%If receiver knows the carrier freq/phase perfectly</span></span><br><span class="line"><span class="keyword">if</span> strcmpi(receiverKnowsCarrier,<span class="string">&#x27;True&#x27;</span>)</span><br><span class="line">    offsetTerm = <span class="number">2</span>*<span class="built_in">pi</span>*fc*t+<span class="built_in">beta</span>;</span><br><span class="line"><span class="comment">%else, estimate the subtraction term</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    p = polyfit(t,inst_phase,<span class="number">1</span>);          <span class="comment">% linearly fit the instaneous phase</span></span><br><span class="line">    <span class="comment">%re-evaluate the offset term using the fitted values</span></span><br><span class="line">    estimated = polyval(p,t); offsetTerm = estimated;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">demodulated = inst_phase - offsetTerm;</span><br><span class="line"><span class="built_in">figure</span>(); <span class="built_in">plot</span>(t,demodulated);          <span class="comment">% demodulated signal</span></span><br><span class="line">title(<span class="string">&#x27;Demodulated signal&#x27;</span>); xlabel(<span class="string">&#x27;n&#x27;</span>); ylabel(<span class="string">&#x27;m(t)&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span> <span class="number">0.5</span> -<span class="built_in">inf</span> <span class="built_in">inf</span>])</span><br></pre></td></tr></table></figure><p>除此之外还有很多不同的调制方式，比如数字信号调制技术。一旦涉及到了数字信号，就需要考虑到信号编码的方式，这样传递的数据才会更加丰富。</p><p>以上就是第八章的大致内容，作者也根据相应的调制内容提供了MATLAB的仿真代码，希望大家能够感受到通信之美。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signal&amp;System </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Signal&amp;System Conclusion Chapter04-05 &amp; 09-10</title>
      <link href="/2024/12/10/Signal&amp;System/Signal-System-Chapter04/"/>
      <url>/2024/12/10/Signal&amp;System/Signal-System-Chapter04/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统-chapter-04-05-09-10-总结归纳"><a href="#信号与系统-chapter-04-05-09-10-总结归纳" class="headerlink" title="信号与系统 chapter 04-05 &amp; 09-10 总结归纳"></a>信号与系统 chapter 04-05 &amp; 09-10 总结归纳</h1><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>在上一篇博客中，我们初步的接触了信号与系统，学习了一个简单但是重要的信号：<strong>单位冲激信号</strong>。对应的，我们学习了在线性时不变系统中如何用单位冲激信号表示一个信号，无论是连续还是离散。以及如果已知单位冲激响应如何求得系统对任何一个信号的响应。由此引入了卷积计算，系统对一个输入信号的响应就等价于输入信号与单位冲激响应做卷积。之后我们通过系统对复指数信号的响应引入了特征函数和特征值的概念，并且表示如果一个信号能够表示为一系列成谐波关系的复指数信号集，那么这个信号就可以写成傅里叶级数，而这样的信号的系统响应很容易求得。</p><h3 id="连续时间的傅里叶级数"><a href="#连续时间的傅里叶级数" class="headerlink" title="连续时间的傅里叶级数"></a>连续时间的傅里叶级数</h3><p>$ x(t) &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jkw_{0}t} &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jk(\frac{2\pi}{T})t}, k &#x3D; 0, 1, 2… $ （综合方程）</p><p>$ a_{k} &#x3D; \frac{1}{T}\int_{0}^{T}x(t)e^{-jkn\omega_{0}t}dt, k \neq 0 $ （分析方程）</p><h3 id="离散时间的傅里叶级数"><a href="#离散时间的傅里叶级数" class="headerlink" title="离散时间的傅里叶级数"></a>离散时间的傅里叶级数</h3><p>$ x[t] &#x3D; \sum_{k&#x3D;(N)}a_{k}e^{jkw_{0}n} &#x3D; \sum_{k&#x3D;(N)}a_{k}e^{jk(\frac{2\pi}{N})n}, k &#x3D; 0, 1, 2… $ （综合方程）</p><p>$ a_{k} &#x3D; \frac{1}{N}\sum_{n&#x3D;(N)}x(t)e^{-jk(2\pi&#x2F;N)n}, k \neq 0 $ （分析方程）</p><p>以上是两个时间下的傅里叶级数, $ a_{k} $称为傅里叶系数，其表征了信号在频谱中对应频率谐波的分量。</p><h2 id="Chapter-04"><a href="#Chapter-04" class="headerlink" title="Chapter 04"></a>Chapter 04</h2><p>以连续时间为例，已知$ a_{k} $的表达式，若我们将等式右边的T乘到左边，那么等式右边与周期T无关。如果我们假设周期$ T $无限大，则$ \omega $无限小，等式右边可以看成一个关于$ \omega $的函数。<br>$$ Ta_{k} &#x3D; \int_{0}^{T}x(t)e^{-jk\omega t}dt $$</p><p>我们称这个表达式为$ Ta_{k} $的包络，记为$ X(j\omega) $。</p><p>通过我们刚才的假设可以很容易的得出，<strong>连续非周期</strong>信号傅里叶变换到频域上表现为一个包络函数。那么<strong>连续周期</strong>信号实质上是<strong>连续非周期</strong>信号在时域上卷积脉冲串，进行时域上的搬移。时卷频乘，对应到频域上就是脉冲串乘上包络函数，即对包络函数采样。</p><p>于是我们有FT:</p><p>$$ Ta_{k} &#x3D; X(j\omega) &#x3D; \mathcal{F}{x(t)} &#x3D; \int_{-\infty}^{\infty}x(t)e^{-j\omega t}dt , \omega &#x3D; k\omega_{0} $$</p><p>一个信号可以表示为傅里叶级数的形式，每一个傅里叶系数都能转换成上述形式，即不同的谐波分量傅里叶变换后的结果不同。</p><p>同时，逆傅里叶变化IFT:</p><p>$$ x(t) &#x3D; \mathcal{F}^{-1}{X(j\omega)} &#x3D; \frac{1}{2\pi}\int_{-\infty}^{\infty} X(j\omega) e^{j\omega t} , d\omega $$</p><p>$ \frac{1}{2\pi} $的由来是将傅里叶级数中的$ a_{k} $用包络函数和周期T的关系代替，周期T又可以表示为$ \frac{2\pi}{\omega} $，由此得到。</p><p>由于傅里叶变换是在能够表示为傅里叶级数的基础上推演得到的，因此傅里叶变换也需要遵循狄利克雷条件，详见上一篇博客。</p><hr><p>那么<strong>连续周期</strong>信号根据我们上面的分析已知，在频域上是脉冲串的加权和。已知一个频域上出现在$ \omega &#x3D; \omega_{0} $幅值为$ 2\pi $的脉冲信号$ X(j\omega) &#x3D; 2\pi \delta(\omega - \omega_{0}) $，通过傅里叶逆变换可以得到其时域表达为$ x(t) &#x3D; e^{j\omega_{0} t} $。如果是一系列频域上出现在$ \omega &#x3D; k\omega_{0} $幅值为$ 2\pi a_{k} $的脉冲加权和，通过逆变换后得到在时域上的表示就等于傅里叶级数的表现形式。</p><p>由此可以得到，<strong>连续周期</strong>信号傅里叶变换后频域上表现为出现在成谐波频率点上乘以对应傅里叶系数的$ 2\pi $倍的脉冲加权和。</p><hr><p>连续时间傅里叶变换的性质这里不做过多讨论，详细请见下表：</p><p><img src="/img/Signal-System/Chapter4-lianxu-FT-table01.png" alt="lianxu table"></p><p><img src="/img/Signal-System/Chapter4-lianxu-FT-table02.png" alt="lianxu table"></p><p><img src="/img/Signal-System/Chapter4-lianxu-FT-table03.png" alt="lianxu table"></p><h2 id="Chapter-05"><a href="#Chapter-05" class="headerlink" title="Chapter 05"></a>Chapter 05</h2><p>上一章中主要讲述了连续时间的傅里叶变换，那么离散时间的傅里叶变换是如何推导的呢？</p><p>我们已知<strong>连续非周期</strong>信号傅里叶变换后在频域上表示为一个包络函数，<strong>连续周期</strong>信号傅里叶变换后在频域上表现为脉冲串对包络函数的采样；</p><p>而我们又知道，离散信号就相当于连续信号在时域上乘以脉冲串进行的采样，根据时乘频卷（多了一个$ \frac{1}{2\pi} $的系数）的性质，离散时间的频域表示就等于连续时间的傅里叶变换做了频谱搬移。</p><p>由此我们可以发现，<strong>离散非周期</strong>信号傅里叶变换后频域上表现为周期包络函数，<strong>离散周期</strong>信号表现为周期包络函数的采样。具体的公式推导如下：</p><p>$ DTFT : X(e^{j\omega}) &#x3D; \sum_{n&#x3D;-\infty}^{+\infty} x[n] e^{-j\omega n} $</p><p>$ IDTFT : x[n] &#x3D; \frac{1}{2\pi} \int_{-\pi}^{\pi} X(e^{j\omega}) e^{j\omega n} d\omega $ </p><p>观察DTFT的表达式可以发现，当$ \omega &#x3D; \omega + 2\pi $时由于n只能为正整数，所以化简后与原式相同。具体来说，离散信号的傅里叶变换是关于频率的周期函数，周期为$ 2\pi $。这是因为离散信号的频谱是连续时间信号频谱的周期性重复。在连续时间信号的傅里叶变换中，频率范围是连续的，但在离散信号的傅里叶变换中，频率范围被限制在$ ((-\pi) - \pi) $之间，然后这个范围内的频谱被周期性地重复。</p><p>同样的，<strong>离散周期</strong>信号的傅里叶变换也可以直接由傅里叶系数导出。已知一个周期序列的傅里叶级数为$ x[n] &#x3D; \sum_{k &#x3D; N}a_{k}e^{jk(2\pi&#x2F;N)n} $，那么它的傅里叶变换就直接等于$ X(e^{j\omega}) &#x3D; \sum_{k&#x3D;-\infty}^{+\infty}2\pi a_{k}\delta(\omega - \frac{2\pi k}{N}) $，即对周期的包络函数采样，符合我们上面的猜想。例如</p><p><img src="/img/Signal-System/Chapter4-lisan-DTFT-example.png" alt="lisan example"></p><hr><p>离散时间傅里叶变换的性质详见下图：</p><p><img src="/img/Signal-System/Chapter4-lisan-DTFT-table01.png" alt="lisan table1"></p><p><img src="/img/Signal-System/Chapter4-lisan-DTFT-table02.png" alt="lisan table2"></p><p><img src="/img/Signal-System/Chapter4-lisan-DTFT-table03.png" alt="lisan table3"></p><p><img src="/img/Signal-System/Chapter4-lisan-DTFT-table04.png" alt="lisan table4"></p><p>以上就是第四、五章的主要内容了，后续我们会对连续时间和离散时间的傅里叶变换做扩展，也就是我们第九、十章的内容，拉普拉斯变换和Z变换。</p><h2 id="Chapter-09"><a href="#Chapter-09" class="headerlink" title="Chapter 09"></a>Chapter 09</h2><p>在这一章中，我们主要介绍了拉普拉斯变换，它是连续时间信号傅里叶变换的一种推广。我们在Chapter 04中学习了一个单位冲激响应为$ h(t) $线性时不变系统对复指数信号的响应等价于一个特征函数与原复指数信号的乘积。即$ y(t) &#x3D; H(s)e^{st} $。其中的特征函数为$ H(s) &#x3D; \int_{-\infty}^{+\infty}h(t)e^{-st}dt $。</p><p>前面讨论的复指数信号中的s是纯虚数，那么对于一般的复变量$ s &#x3D; \sigma + j\omega $来说，$ H(s) $就是单位冲激响应的拉普拉斯变换。我们定义一个信号的拉普拉斯变换为：</p><p>$ X(s) &#x3D; \mathcal{L}{x(t)} &#x3D; \int_{0}^{\infty}x(t)e^{-st} dt $</p><p>当信号的复指数不为纯虚数时，拉普拉斯变换可以表示为：</p><p>$ X(\sigma + j\omega) &#x3D; \mathcal{L}{x(t)} &#x3D; \int_{0}^{\infty}x(t)e^{-(\sigma + j\omega)t} dt &#x3D; \int_{0}^{\infty}x(t)e^{-\sigma}e^{-j\omega t} dt $</p><p>可以将拉普拉斯变换理解为在输入信号$ x(t) $上增加了一个实指数的增益。这个增益$ e^{-\sigma} $在时间上可以是衰减或者递增的，这取决于$ \sigma $是正还是负。</p><p>特殊的，对于两个不同的信号其拉普拉斯变换结果可能相同，只是保证收敛的s的取值范围不同（往往拉普拉斯变换结果相同的两个信号取值范围互补），所以我们给出一个信号的拉普拉斯变换时要将s的取值范围和表达式一起给出。我们称这个s的取值范围为拉普拉斯变换的收敛域，记为$ ROC $。</p><p>一个信号可以表示为复指数信号集的形式，那么我们可以单独对每一个复指数信号做拉普拉斯变换，计算其收敛域，最后将所有拉普拉斯变换的结果求和，$ROC$取所有收敛域的交集。只要$x(t)$是实指数或复指数信号的线性组合，那么其拉普拉斯变换$X(s)$一定是有理的，可以表现为$ X(s) &#x3D; \frac{N(s)}{D(s)} $。而使$N(s)$等于零的s我们称为$X(s)$的零点，同理使$D(s)$等于零的s称为极点。由于拉普拉斯变换的表达式不能确认$X(s)$自身的收敛域，所以说一个有理拉普拉斯变换的完全表征由$X(s)$的零-极点图和收敛域共同构成。</p><p>无穷远零点\极点：如果拉普拉斯变换的表达式中分母阶数超过分子阶数k阶，在收敛域内我们说拉普拉斯在无穷远处存在k阶零点；若分子阶数超过分母k阶，在收敛域内我们说拉普拉斯变换在无穷远处存在k阶极点。</p><p>已知当$\sigma &#x3D; 0, s &#x3D; j\omega$时，拉普拉斯变换就是傅里叶变换，若拉普拉斯变换的收敛域不包括$ j\omega $轴即$ \omega &#x3D; 0 $则表示该傅里叶变换不收敛。那么拉普拉斯变换的收敛域有什么性质吗？</p><ul><li>收敛域的取值只与s的实部有关，即在s平面内是平行与纵轴的带状区域</li><li>对有理拉普拉斯变换来说，收敛域内不存在极点（注意无穷远处）</li><li>如果输入信号时域上长度有限，且绝对可积则收敛域是整个s平面。解释：可以看成一个有限且可积的信号乘上一个实指数的增益做傅里叶变换，由于满足可积条件则傅里叶变换的结果是一个包络函数，即无穷长度（<strong>连续非周期</strong>信号）</li><li>如果原输入信号是右边信号，且某点在拉普拉斯变换的收敛域内，则该点右边全部的s值都一定在收敛域内。</li><li>同理，如果是左边信号，则该点处的左边所有s值都一定在收敛域内。</li><li>如果是双边信号，且已知某点在收敛域内，则完整收敛域一定是包含该点的一个带状区域。</li><li>如果拉普拉斯变换是有理的，那么其收敛域是被极点界定的或延伸至无穷远处。此外，收敛域内不包含极点。</li><li>如果有理，若是右边信号则收敛域在最右边极点的右边；若是左边信号则收敛域在最左边极点的左边。</li></ul><p>拉普拉斯逆变换的表达式为：</p><p>$ x(t) &#x3D; \frac{1}{2\pi j}\int_{\sigma - j\omega}^{\sigma + j\omega}X(s)e^{st}ds $</p><p>$x(t)$可以用一个复指数信号的加权积分表示，积分路径为s平面内过$ Re{s} &#x3D; \sigma $的平行于纵轴的一条直线。若拉普拉斯变换有理，则一般将拉普拉斯变换拆分成若干个简单分式，通过固定的变换对反解$x(t)$中的复指数分量，最后加权求和。</p><hr><p>拉普拉斯变换的性质表现如下：</p><p><img src="/img/Signal-System/Chapter9-lianxu-laplace-table01.png" alt="lianxu laplace"></p><p><img src="/img/Signal-System/Chapter9-lianxu-laplace-table02.png" alt="lianxu laplace"></p><h3 id="如何通过拉普拉斯变换表征线性时不变系统特性"><a href="#如何通过拉普拉斯变换表征线性时不变系统特性" class="headerlink" title="如何通过拉普拉斯变换表征线性时不变系统特性"></a>如何通过拉普拉斯变换表征线性时不变系统特性</h3><ol><li>因果性：收敛域是某个右半平面。若是有理拉普拉斯变换，则收敛域是最右边极点的右半平面。</li><li>稳定性：当且仅当系统的单位冲激信号的拉普拉斯变换（特征值函数）的收敛域包含S &#x3D; 0。有理拉普拉斯变换的所有极点都要在s平面的左半平面时一个有理因果系统才稳定。</li></ol><p>对于一个用线性常系数微分方程表征的线性时不变系统，他的系统函数为$ H(s) &#x3D; \frac{Y(s)}{X(s)} $。由拉普拉斯逆变换可以将拉普拉斯变换后的系统函数还原回单位冲激响应。注意！通过线性常系数微分方程获得的系统函数没有收敛域的限制，可若是给出系统因果或者稳定则需要加上收敛域的推演。或者通过对收敛域的判定，可以推导出满足的系统具有的特性如因果、稳定性等。</p><h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><p>对于Z变换的引入与拉普拉斯变换的目的相同，Z变换的性质与拉普拉斯变换的性质十分相似。</p><p>$$ X(z) &#x3D; \sum_{n&#x3D;-\infty}^{\infty} x[n] z^{-n} $$</p><p>以上是Z变换的公式，其中的Z的一般式表现为$ Z &#x3D; re^{j\omega} $。等效后，Z变换的公式变为：</p><p>$$ X(re^{j\omega}) &#x3D; \sum_{n&#x3D;-\infty}^{\infty} x[n] (re^{j\omega})^{-n} &#x3D; \sum_{n&#x3D;-\infty}^{\infty} (x[n]r^{-n})e^{-j\omega n} $$</p><p>跟拉普拉斯变换思想一样，对原离散输入信号乘上一个实指数的增益，然后做离散时间的傅里叶变换。在第九章中，我们说当s的实部$\sigma$为零时，拉普拉斯变换就等效于傅里叶变换，这也表明，在复平面内虚轴上的拉普拉斯变换就是傅里叶变换。而对于离散时间的Z变换来说，当Z的模长为一时，Z变换就等效于离散时间的傅里叶变换。在复平面内，我们称这个模长为一的圆为<strong>单位圆</strong>。由于离散时间傅里叶变换的收敛条件，要求添加增益后的输入信号满足离散傅里叶变换的收敛条件，由此可以得到r即z的模长的取值范围。我们同样称之为$ROC$收敛域。</p><p>同样的，Z变换跟拉普拉斯变化一样对于有理的Z变换可以通过零点、极点的分布来判断系统的收敛域。只是拉普拉斯变换的收敛域是复平面内平行于纵轴的条带型区域；而Z变换的收敛域是复平面内以原点为圆心一系列圆，可能圆外、圆内或者圆环。当Z变换的收敛域包含单位圆时，我们可以说该系统稳定，输入信号的离散傅里叶变换收敛。同样的，Z变换的收敛域也有一些性质：</p><ul><li>对有理Z变换来说，收敛域内不存在极点（注意无穷远处、原点处）</li><li>如果输入信号是有限长序列，则收敛域是整个Z平面，有可能去除原点和无穷远处。</li><li>如果输入信号是右边信号，且某半径的圆在Z变换的收敛域内，则半径大于该圆的全部圆都一定在收敛域内。</li><li>同理，如果是左边信号，则该圆内部所有半径的圆都一定在收敛域内。</li><li>如果是双边信号，且已知某半径的圆在收敛域内，则完整收敛域一定是包含该圆的一个圆环。</li><li>如果Z变换是有理的，那么其收敛域是被极点界定的或延伸至无穷远处。此外，收敛域内不包含极点。</li><li>如果Z变换是有理的，且原信号是右边序列，则收敛域位于Z平面最外层极点的外边，即半径最大的圆外面；同理左边序列则是最小的圆内部。若因果，则右边序列的Z变化包含无穷远处；左边序列的Z变换收敛域包含原点处。</li></ul><p>Z逆变化的表达式如下：</p><p>$$x[n] &#x3D; \frac{1}{2\pi j} \oint_C X(z) z^{n-1} , dz$$</p><p>原信号等于在半径为r的Z平面上一个封闭圆沿逆时针绕一圈做积分，这个r可以是收敛域中的任何一个值。与拉普拉斯逆变换相对应，拉普拉斯逆变换是在收敛域的一条纵向直线上做积分，Z逆变换是在收敛域内的一个圆形轨迹上做闭曲线积分。因此，对于有理的Z变换，可以先因式分解为几个简单的分式加权求和，分别做Z逆变换，最终加权求和得到原输入信号。<br>与之相对应的，每一个分式应该有自己的极点，那么如果$X(z)$的收敛域位于某个分式的极点外侧，则Z逆变换后的对应量系数为正；若收敛域在某个分式的极点内侧，则逆变换后的相应项的系数为负。</p><p>对于非有理的Z变换，使用幂级数展开法且Z逆变换十分有效，具体思想就是将Z变换通过长除法等手段写成幂级数（$a_{k}z^{-k}$）的形式，其中当$n &gt; 0$时$a_{k}$就是对应$x[-k]$的值；而当$n &lt; 0$时，$a_{k}$就是对应$x[k]$的值。除此之外还有泰勒级数展开等等，这里不多做描述。</p><hr><p>Z变换的性质表现如下：</p><p><img src="/img/Signal-System/Chapter10-lisan-Z-table01.png" alt="lisan laplace"></p><p><img src="/img/Signal-System/Chapter10-lisan-Z-table02.png" alt="lisan laplace"></p><p>与拉普拉斯变换相同的，我们可以用Z变化来表征线性时不变系统的特性。如下：</p><ul><li>因果性：当且仅当系统的收敛域在某个圆的外边且包括无限远处。若系统还是有理的，则收敛域位于最外层的极点的外边；且若系统函数H()表示为关于s的多项式之比，分子阶数需要低于分母阶数。</li><li>稳定性：当且仅当系统的单位冲激响应的Z变换的收敛域包含单位圆。若系统还是有理的，则系统函数的所有极点都需要位于单位圆内，即所有极点的模长都要小于一。</li></ul><h2 id="系统框图表示系统函数"><a href="#系统框图表示系统函数" class="headerlink" title="系统框图表示系统函数"></a>系统框图表示系统函数</h2><p>对于一个有理的系统函数，我们可以表示为$H(s) &#x3D; \frac{Y(s)}{X(s)}$，这样我们可以得到y、x之间的关系，无论是变换后的还是原始的。这样我们可以通过系统框图表示该系统。一阶系统一般表示为一个系统框图，高阶的系统可以表现为多个一阶系统之间的级联或者并联。<br>下面是两个简单的系统框图：</p><p><img src="/img/Signal-System/Chapter9-lianxu-laplace-diagram.png" alt="拉普拉斯变换 diagram"></p><p><img src="/img/Signal-System/Chapter10-lisan-Z-diagram.png" alt="Z变换 diagram"></p><p>以上就是全部的知识总结了，希望对你有帮助。下一篇就是本书的最后的内容了，我们会开始采样、滤波和信号的调制解调，敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signal&amp;System </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Signal&amp;System Conclusion Chapter01-03</title>
      <link href="/2024/12/09/Signal&amp;System/Signal-System-Chapter01/"/>
      <url>/2024/12/09/Signal&amp;System/Signal-System-Chapter01/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统-chapter-01-03-总结归纳"><a href="#信号与系统-chapter-01-03-总结归纳" class="headerlink" title="信号与系统 chapter 01-03 总结归纳"></a>信号与系统 chapter 01-03 总结归纳</h1><h3 id="Tips：本博客中设计大量-Latex-公式，需要在浏览器中安装相应的插件支持-Latex-公式的显示"><a href="#Tips：本博客中设计大量-Latex-公式，需要在浏览器中安装相应的插件支持-Latex-公式的显示" class="headerlink" title="Tips：本博客中设计大量 Latex 公式，需要在浏览器中安装相应的插件支持 Latex 公式的显示"></a>Tips：本博客中设计大量 Latex 公式，需要在浏览器中安装相应的插件支持 Latex 公式的显示</h3><h2 id="Chapter-01"><a href="#Chapter-01" class="headerlink" title="Chapter 01:"></a>Chapter 01:</h2><p>简单来说，章节一简单的介绍了一下什么是信号、什么是系统。以及介绍了一些常见的信号变化方式。那么我们需要关注的就是信号的分类，以下是几个非常重要的信号分支：</p><ol><li><strong>连续信号\离散信号</strong></li><li><strong>周期信号\非周期信号</strong></li></ol><p>第一类与第二类的信号可以相互组合，总共四种：</p><ul><li>连续周期</li><li>连续非周期</li><li>离散周期</li><li>离散非周期</li></ul><p>后续讨论的一切信号处理皆建立在这四类信号的基础上。不同的信号时域、频域的转换以及表现都不相同，对信号变化的响应也不相同。在这四种信号类型之外，介绍了一些常见的信号，如指数信号、正弦信号，表达式如下：<br>$$ x(t) &#x3D; Ae^{j\omega t} $$<br>经过欧拉公式变形后，信号的表现形式如下：<br>$$ x(t) &#x3D; A(cos\omega_{0} t + j sin\omega_{0} t) $$</p><p>可以发现，复指数信号是一个周期函数且可以展开为三角函数的形式，这也为我们后面的讨论定下了基础。其中 <strong>A</strong> 表示为信号的幅值，而 $ \omega_{0} $ 表现了信号的振荡速度即在复平面内的旋转速度。上述信号为连续信号，因此我们可以发现当$ \omega_{0} $持续增大时，对应振荡速率也在不断增大，周期不断减小。周期为 $ T &#x3D; \frac{2\pi}{\omega_{0}} $  </p><p>那么我们观察一下离散的复指数信号：<br>$$ x[n] &#x3D; Ae^{j\omega n} $$<br>如果我们将$ \omega_{0} $不断增大到$ \omega_{0} + 2\pi $时，你会发现由于$ n $只能为整数，所以$ e^{j2\pi n} $的值恒为1，这也表示离散信号的频率不能无限增大，离散信号的$ \omega_{0} $只能在范围$ 0-2\pi $或者$ (-\pi)-\pi $。这里体现了连续信号与离散信号之间的区别。除此之外，连续时间的复指数信号恒为周期信号，而离散信号由于n只能取整数点，因此是否是周期信号还取决于$ \omega_{0} $的取值，$ N &#x3D; \frac{m2\pi}{\omega_{0}} $必须为正整数才能是周期信号。</p><p>其次介绍了一些常见的信号时域上的变化，如平移、尺度变换、时间反转等，详见如下：</p><ul><li>反转: $ x(-t) &#x3D; x^{*}(t) $；信号在时域上反转</li><li>尺度变换: $ x(at) $；当$ a &gt; 1 $时相当于加速，信号时域上压缩；$ a &lt; 1 $时相当于减速，信号时域上拉长</li><li>平移: $ x(t - T_{0}) $；信号在时域上左右平移，$ T_{0} $为平移后原信号零时刻的位置。</li><li>信号的分解：任何一个信号都可以分解为一个奇信号和一个偶信号的和。$ Odd{x(t)} &#x3D; \frac{1}{2}(x(t) - x(-t)) $;$ Even{x(t)} &#x3D; \frac{1}{2}(x(t) + x(-t)) $</li></ul><p>通常来说，信号的变化会将反转，平移以及拉伸变换一起进行考察。我们将反转、拉伸定义为变换一，将平移定义为变换二。那么有两种变化顺序：</p><ul><li>顺序一：先一后二 -&gt; $ A(t - t_{0}) $；先对时域做伸缩或者反转，再在变化后的时间轴上进行平移。</li><li>顺序二：先二后一 -&gt; $ At + t_{0} $；先在时间轴上进行平移，再对时域做伸缩或者反转。因为是以y轴为对称的变化，而根据平移的特点，$ t_{0} $就是平移后的原点位置，因此不需要对$ t_{0} $伸缩或反转。</li></ul><p>之后介绍了两个全新的信号，阶跃信号$ u(t) $和单位冲激信号$ \delta(t) $。阶跃信号在$ t &#x3D; 0 $时取值为1，在$ t &lt; 0 $时取值为0，在$ t &gt; 0 $时取值为1。单位冲激信号在$ t &#x3D; 0 $时取值为1，在$ t \neq 0 $时取值为0。且阶跃信号是单位冲激信号的积分。单位冲激信号是阶跃信号的微分。离散信号与连续性质相同。</p><p>接着介绍了系统的一些特性，详见如下：</p><ul><li>记忆性：系统当前时刻的输出与过去时刻的输入有关。无记忆就是指当前输出只与当前输入有关。</li><li>可逆性：系统的输出与输入的关系是可逆的。存在另一个系统能将前一个系统的输出作为输入，将前一个系统的输入作为输出。</li><li>因果性：系统的输出只与当前时刻的输入和过去时刻的输出有关。当前时刻的输出不能够预测未来时刻的输入。</li><li>稳定性：有界的输入得到的是有界的输出。</li></ul><p>还有常见的两个特殊系统：</p><ul><li>线性系统：系统的输出只与输入的线性组合有关。包括可加性和齐次性。输入的加权求和输入系统得到的是对应输出的加权求和输出。</li><li>时不变系统：输入的延迟输入系统得到的是对应输出的延迟输出。</li></ul><h2 id="Chapter-02"><a href="#Chapter-02" class="headerlink" title="Chapter 02:"></a>Chapter 02:</h2><p>第二章中介绍了一个重要的运算：<strong>卷积</strong>。以及对于一个线性时不变系统，输入一个信号如何得到对应的响应。</p><p>首先从离散信号开始，我们发现离散信号可以用一系列的加权冲激信号表示。$ x[n] &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}\delta[n - k] * x[k] $。这个式子表示对于一个选定的n当且仅当k为n时，$ \delta[n - k] $才有值，否则为0。那么我们可以将$ \delta[n - k] $看作是一个冲激信号，那么$ x[n] $就可以看作是一系列的冲激信号的加权和。</p><p>既然一个离散信号我们可以表示为一系列加权脉冲的求和，那么要是我们知道一个线性时不变系统对一个单位脉冲信号的响应，则对于所有的信号的响应可以变成一系列加权脉冲响应的求和。这样我们实现了求一知N。公式表达如下：<br>$$ y[n] &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}h_{k}[n] * x[k] $$<br>$ h_{k}[n] $表示时移为k的单位脉冲响应。又系统是时不变的，所以单位冲激信号时移后的响应等于单位冲激信号的响应的时移。因此我们可以将公式简化为：<br>$$ y[n] &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}h[n - k] * x[k] $$<br>那么我们就将卷积运算的定义推演出来了，这个公式表达为一个平移从$ -\infin $到$ +\infin $的脉冲串求响应，再乘上$ x[k] $对应位置的权值，最后求和。那么我们怎么才能更好的记住这个公式呢？先将原信号的变量变为$ k $，再将单位冲激响应反转$ h[k] $变为$ h[-k] $，最后将响应平移到$ -\infin $处开始从左向右平移$ h[-k] $变为$ h[n-k] $，对于每一个n值都要将$ h[n-k] $与$ x[k] $对应位置的权值相乘，最后求和。这样就得到了我们完整的响应$ y[n] $。</p><p>粗略的我们将卷积公式记为：$ y[n] &#x3D; x[h] * h[n] $；完整的计算公式为 $ y[n] &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}h[n - k] * x[k] $。</p><p>线性时不变系统中的卷积运算满足一些运算的性质：</p><ul><li>交换律：$ x[n] * h[n] &#x3D; h[n] * x[n] $</li><li>结合律：$ (x[n] * h[n]) * h[n] &#x3D; x[n] * (h[n] * h[n]) $</li><li>分配律：$ x[n] * (h[n] + h[n]) &#x3D; x[n] * h[n] + x[n] * h[n] $</li><li>无记忆：当前信号的响应只与自身有关，根据卷积计算公式可得单位冲激响应只能是 $ h[n] &#x3D; K\delta[n] $。</li><li>可逆性：存在逆单位冲激响应使得$ h_{1}[n] * h[n] &#x3D; \delta[n] $。</li><li>因果性：当且仅当$ h[n] $只在 $ t &gt; 0 $的时候不为零。</li><li>稳定性：单位冲激响应绝对可积，则说明系统的输出必然有界。这是离散线性时不变系统稳定的充要条件。</li></ul><p>第二章还介绍了如何求解微分方程和差分方程描述的因果线性时不变系统的响应。对于线性常系数微分方程描述的系统，其输出通常是一个特解和一个通解的线性组合。我们通常假设通解为指数函数的形式代入微分方程，根据初始系统的零响应（初始松弛条件），即$ y(0) &#x3D; 0 $或$ y[0] &#x3D; 0 $。差分方程的求解过程类似，但是特殊的，由于离散时间所以是有限个点，因此在初始条件已知的情况下我们可以通过递归求得最终输出。例如<br>$$ y[n] - \frac{1}{2}y[n-1] &#x3D; x[n], x[n] &#x3D; K\delta[n] $$</p><p>当$ n &lt; 0 $时，系统的输入为零。因此，我们可以通过递归的方式求得$ y[n] $的值。</p><p>对于一些复杂的一阶微分或差分方程，我们可以通过系统框图来表示系统的响应。<img src="/img/Signal-System/Chapter2-System-diagram.png" alt="xitong diagram"></p><p>当然除了离散时间的信号满足上面的性质，连续时间信号同样能够用一系列的加权脉冲求和表示，知道连续时间单位冲激响应后我们也可以求得任何一个连续时间信号对于连续时间线性时不变系统的响应。只不过，离散时间是求和，连续时间是积分。<br>$$ x(t) &#x3D; \int_{-\infin}^{+\infin}x(\tau)\delta(t-\tau)d\tau $$<br>对于任何一个t时刻的输入，等于$ x(\tau) $与$ \delta(t - \tau) $乘积在整个时间轴上的求和，虽然只有$ t &#x3D; \tau $时不等于零。相应的，卷积公式变为：<br>$$ y(t) &#x3D; x(t) * h(t) &#x3D; \int_{-\infin}^{+\infin}x(\tau)h(t - \tau)d\tau $$</p><p>同样是要在连续时间的线性时不变系统中才成立。</p><p>综上，第二章的内容就介绍到这里。主要介绍了卷积在离散时间和连续时间的表达式以及如何理解。并且给出了卷积在线性时不变系统中如何体现线性时不变系统的几个性质的。如因果性、可逆性等。</p><h2 id="Chapter-03"><a href="#Chapter-03" class="headerlink" title="Chapter 03:"></a>Chapter 03:</h2><p>第三章引入了傅里叶级数，以及如何求得一个信号的傅里叶级数，我们依旧是从连续和离散两个角度来讨论。</p><p>首先从我们第二章中，我们学到了线性时不变系统的单位冲激响应，我们现在介绍一个新的响应，特征响应（特征方程）。如果一个信号输入一个复指数信号，由我们前面得到的单位冲激响应可以推导出复指数信号$ x(t) &#x3D; e^{st} $的响应：<br>$$ y(t) &#x3D; \int_{-\infin}^{+\infin}h(\tau)x(t-\tau)d\tau $$<br>即<br>$$ y(t) &#x3D; \int_{-\infin}^{+\infin}h(\tau)e^{s(t-\tau)}d\tau $$<br>$$ y(t) &#x3D; e^{st}\int_{-\infin}^{+\infin}h(\tau)e^{-s\tau}d\tau $$</p><p>我们将$ e^{st} $提取出来，可以发现系统输出等于输入信号$ e^{st} $与一个$ H(s) $的乘积。我们称常数$ H(s) $（可以是复数）为与特征函数$ e^{st} $有关的特征值。<br>$$ H(s) &#x3D; \int_{-\infin}^{+\infin}h(\tau)e^{-s\tau}d\tau $$</p><p>上述分析对于离散时间的复指数信号也成立。这样我们可以将系统的输出表示为简单的特征值与输入信号乘积的形式，即$ y(t) &#x3D; H(s)e^{st}, y[n] &#x3D; H[z]z^{n} $。</p><hr><p>已知特征值只与输入信号的复数值有关，如果我们能够求出系统的特征值函数，并且将输入信号表示为一系列复指数信号的求和，那么我们根据特征函数响应与线性时不变系统的线性性可以求得输出信号。</p><p>那么什么信号能够分解为一系列的复指数信号呢？我们在第一章中介绍了周期复指数信号$ x(t) &#x3D; e^{jw_{0}t} $。那么一系列与$ x(t) $成谐波关系的复指数信号集就是：<br>$$ x(t) &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jkw_{0}t} &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jk(\frac{2\pi}{T})t}, k &#x3D; 0, 1, 2… $$</p><p>每一项称为k次谐波。那么若一个周期信号可以表示为上述一系列谐波分量的集合的形式，我们就称为<strong>傅里叶级数表示</strong>。通过数学公式的变形以及欧拉公式的展开，我们可以得到傅里叶级数的另一个表达形式：<br>$$ x(t) &#x3D; a_{0} + \sum_{k&#x3D;1}^{\infin}(a_{k}e^{jkw_{0}t} + a_{-k}e^{-jkw_{0}t} ) $$<br>对于实周期的信号常见的傅里叶级数则是：<br>$$ x(t) &#x3D; a_{0} + \sum_{k&#x3D;1}^{\infin}\lvert a_{k} \rvert cos(kw_{0}t+\theta_{0}) $$</p><p>回到本篇文章常见的复指数形式的傅里叶级数，我们如何求得傅里叶级数$ a_{k} $呢？对复指数信号集左右同时乘一个$ e^{-jn\omega_{0}t} $并且做一个周期内的积分可以得到：</p><p>$$ \int_{0}^{T}x(t)e^{-jkn\omega_{0}t}dt &#x3D; \int_{0}^{T}\sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jkw_{0}t}e^{-jkn\omega_{0}t}dt $$<br>等式的右边由于是周期函数，一个周期的积分为零，当且仅当$ k &#x3D; 0 $时，右边的谐波分量等于1，因此在一个周期内的积分就等于周期$ T $，因此我们可以得到：<br>$$ a_{k} &#x3D; \frac{1}{T}\int_{0}^{T}x(t)e^{-jkn\omega_{0}t}dt $$<br>这就是连续时间周期信号的傅里叶级数的计算方式。如此我们便通过两个方程确定了连续周期信号的傅里叶级数。</p><p>$ x(t) &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jkw_{0}t} &#x3D; \sum_{k&#x3D;-\infin}^{+\infin}a_{k}e^{jk(\frac{2\pi}{T})t}, k &#x3D; 0, 1, 2… $ （综合方程）</p><p>$ a_{k} &#x3D; \frac{1}{T}\int_{0}^{T}x(t)e^{-jkn\omega_{0}t}dt, k \neq 0 $ （分析方程）</p><h3 id="注意：想用傅里叶级数表示一个连续周期信号，需要满足狄利克雷条件"><a href="#注意：想用傅里叶级数表示一个连续周期信号，需要满足狄利克雷条件" class="headerlink" title="注意：想用傅里叶级数表示一个连续周期信号，需要满足狄利克雷条件"></a>注意：想用傅里叶级数表示一个连续周期信号，需要满足狄利克雷条件</h3><ol><li>在任何周期内，信号$ x(t) $必须绝对可积。信号$ x(t) &#x3D; \frac{1}{t} $就不满足条件一。</li><li>任意有限区间内只有有限个起伏变化，即最大最小值数量有限。信号$ x(t) &#x3D; sin(\frac{2\pi}{t}) $不满足条件二。</li><li>有限区间只有有限个不连续点。</li></ol><p>对于连续周期信号的傅里叶级数满足一些性质：</p><ul><li>线性：加权可加</li><li>平移：平移后傅里叶系数多了一个跟平移量有关的复指数（幅角变、幅值不变）</li><li>时间反转：原级数也反转</li><li>尺度变换：傅里叶系数不变，但是基波频率改变，傅里叶级数改变。</li><li>相乘：信号相乘，对应傅里叶系数相卷。</li><li>共轭：当信号是实信号时，傅里叶系数一定共轭对称。若信号是实偶信号，则傅里叶系数也是实偶函数；如果信号是实奇函数，则傅里叶系数也是实奇函数。</li><li>帕斯瓦尔定理：周期信号的总平均功率等于各谐波平均功率之和</li></ul><p>$$ \frac{1}{T}\int_{T}\lvert a_{k}e^{jk\omega_{0} t} \rvert^{2}dt &#x3D; \frac{1}{T}\int_{T}\lvert a_{k}\rvert^{2}dt &#x3D; \lvert a_{k}\rvert^{2} $$</p><p>具体总结详见下表：</p><p><img src="/img/Signal-System/Chapter3-lianxu-table01.png" alt="lianxu table"></p><hr><p>对于离散周期的信号仍然有上述的性质，两者几乎相同：</p><p>$ x[n] &#x3D; \sum_{k&#x3D;(N)}a_{k}e^{jkw_{0}n} &#x3D; \sum_{k&#x3D;(N)}a_{k}e^{jk(\frac{2\pi}{N})n}, k &#x3D; 0, 1, 2… $ （综合方程）</p><p>$ a_{k} &#x3D; \frac{1}{N}\sum_{n&#x3D;(N)}x(t)e^{-jk(2\pi&#x2F;N)n}, k \neq 0 $ （分析方程）</p><p>上述综合方程与连续时间不同的原因是，连续周期信号可以有无限多的谐波分量，因为t是连续的，$ \omega $不断增大对应的谐波分量也不同。而离散时间不一样，像第一章讨论的一样，离散周期信号的复指数谐波信号集里面只有N个信号是不同的，相差$ 2\pi $的复指数信号完全相同。</p><p>而且，由于离散周期信号是由有限个复指数谐波信号集组成的，因此离散周期信号的能量有限，不需要考虑信号收敛的问题。离散傅里叶级数的性质见下表：</p><p><img src="/img/Signal-System/Chapter3-lisan-table02.png" alt="lisan table"></p><p>以上就是我对信号与系统Chapter01 至 Chapter03的全部心得体会以及总结。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signal&amp;System </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32H723-ADC</title>
      <link href="/2024/11/25/STM32H723_ADC/STM32H723-ADC/"/>
      <url>/2024/11/25/STM32H723_ADC/STM32H723-ADC/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32H723ZGT6-Development-log01-ADC"><a href="#STM32H723ZGT6-Development-log01-ADC" class="headerlink" title="STM32H723ZGT6 Development log01 - ADC"></a><em><strong>STM32H723ZGT6 Development log01 - ADC</strong></em></h1><h2 id="What-is-ADC"><a href="#What-is-ADC" class="headerlink" title="What is ADC"></a><em><strong>What is ADC</strong></em></h2><p>The ADC, analog to digital conversion, is a tool to sample the analog values of voltage and transform to digital data. The range of digital data depends on the accuracy of ADC which can be 12bits, 14bits or even 16bits. The choices above are all provided in <em><strong>STM32H723ZGT6</strong></em> and I personally recommend to use 14bits which mean $ 0-2^{14} $. Above all, ADC is a tool that can sample the analog values and transform to digital stored in STM32 so that we can calculate its real value and process it.</p><h2 id="How-to-quickly-start-ADC"><a href="#How-to-quickly-start-ADC" class="headerlink" title="How to quickly start ADC"></a><em><strong>How to quickly start ADC</strong></em></h2><p>Due to its wide usage, there are different way to enable ADC and to sample value. We will introduce the mostly used three ways.</p><h3 id="ADC-TIM"><a href="#ADC-TIM" class="headerlink" title="ADC + TIM"></a><em><strong>ADC + TIM</strong></em></h3><p>The first way is to enable a <em><strong>TIMER</strong></em> as a external trigger which enable ADC to sample when the timer count to setting time. It means if you enable the TIM’s Auto-reload, then you will get sample values at the frequency of selected trigger timer. The comprehensive configuration is followed.</p><p><img src="/img/STM32H723-ADC/ADC1-Timer-single-conversion.png" alt="ADC1"></p><p>It is easy to configure in this way. <em><strong>Pay attention to the red block I circle!</strong></em> I will comprehensively introduce the use of those configuration so that you can make you own way to enable ADC sample.</p><ul><li><em><strong>Scan Conversion Mode</strong></em>: Disable when you only use one channel of selected ADC. The <em><strong>“Scan”</strong></em> means <em><strong><span style="color: red">Scan Multiple Channel</span></strong></em>. So if you sample many channels’s value, you need to enable Scan Mode.</li><li><em><strong>Continuous Conversion Mode</strong></em>: If you don’t use DMA or just sample one single values in one round conversion, you can disable the continuous conversion mode. What the continuous conversion means <em><strong><span style="color: red">if you want a list a data, then it will continuously sample the values until fulfill the list.</span></strong></em>. You can simply understand that it is continuous between two bits.</li><li><em><strong>DMA Circle</strong></em>: Similar to the continuous conversion mode mentioned above, the DMA circle mode also means continuous conversion. <em><strong><span style="color: red">But what is different is that the “continuous” means continuous conversion between two round!</span></strong></em>. It is said that if ADC finish to fill a list of data like data[128], then it will start next conversion of a list of data <em><strong>Automatically</strong></em> which will cover the data of last round.</li><li><em><strong>End of Conversion Selection</strong></em>: This configuration contains two choices. If you only use one channel to sample then the <em><strong>“End of single conversion”</strong></em> is fine. But if you use multiple channel to sample then you need to choose <em><strong>“End of sequence conversion”</strong></em> .</li><li><em><strong>Number of Conversion</strong></em>: The number of conversion is the number of channel that you choose.</li><li><em><strong>External Trigger Conversion Source</strong></em>: The most commonly used is <em><strong><span style="color: red">Timerx Trigger Out event or By software</span></strong></em> . The first choice is often used when you need to sample at some exact frequency, espacially in signal sample. And the latter simply enable the ADC by a code to start it. When you use the first choice, don’t forget to enable <em><strong>TIMx’s NVIC</strong></em> and configure update event which means if the clock is over than the <em><strong>TIMx</strong></em> will produce a update event and this event can drive the ADC to sample.</li><li><em><strong>External Trigger Conversion Edge</strong></em>: This usually use default settings.</li></ul><p>And the code you should write is also simple.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED); <span class="comment">// accurate adc(must)</span></span><br><span class="line">HAL_ADC_Start_IT(&amp;hadc1);</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim15);</span><br></pre></td></tr></table></figure><p>Through experiment verified, the first line of code is necessary, which accurate the value of sample. The rest of code is Start <em><strong>ADC IT</strong></em> and start <em><strong>TIM 15</strong></em> as trigger source.<br>And you can read values in ADC Callback function like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef *hadc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// single conversion IT sample </span></span><br><span class="line">  <span class="keyword">if</span> (hadc-&gt;Instance == ADC1)</span><br><span class="line">  &#123;</span><br><span class="line">    digital_v = HAL_ADC_GetValue(hadc);</span><br><span class="line">    Voltage = <span class="number">3.3</span> * digital_v / <span class="number">16384</span>;</span><br><span class="line">    HAL_ADC_Start_IT(hadc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remember to restart ADC if you want to continuous sample. I recommend you write the restart code in Callback function so that you ensure your ADC next conversion starts after the previous done.</p><h3 id="ADC-DMA"><a href="#ADC-DMA" class="headerlink" title="ADC + DMA"></a><em><strong>ADC + DMA</strong></em></h3><p>The second way is one-round sample a list of data with DMA triggered by software. The specific configuration is followed.</p><p><img src="/img/STM32H723-ADC/ADC2-DMA.png" alt="ADC2"></p><p>What is special of this configuration is that it only sample one round of a list of data like data[128]. The important point of the configuration is the configuration of DMA which is as followed.</p><p><img src="/img/STM32H723-ADC/ADC2-DMA-Normal.png" alt="ADC2_DMA"></p><p>In this way, we use Normal mode of DMA rather than Circle mode which mentioned above means continuously sample round and round, which reveals that when ADC finish sample tasks, you don’t need to restart ADC-DMA for next round of sample because it will start by itself. On the contrary, we configure Normal mode so if you want a new round of sample after last round, you should restart ADC-DMA in the Callback function or somewhere else.</p><p>Usually, this function is used when you want to preserve the data and make data process. For an example, you want to sample a list of data of signal and then do FFT or calculate the DC values of it. This way is suitable for you.</p><h3 id="ADC-DMA-TIM"><a href="#ADC-DMA-TIM" class="headerlink" title="ADC+DMA+TIM"></a><em><strong>ADC+DMA+TIM</strong></em></h3><p>In the last part of previous section, we have mentioned about the sample of signal. If you know some basic knowledge of signal sample, you should know the <em><strong>Nyquist Sample theory</strong></em> which says that the sample rate of a signal should be twice larger than the frequency of signal you want to sample so that you can do accurate FFT and recover its wave shape.</p><p>So we try to use TIM as an external trigger which we can set the time it trigger. And we configure the Circle mode of DMA which automatically enable ADC sample after one round so that we could get data continuously. The configuration is as followed.</p><p><img src="/img/STM32H723-ADC/ADC3-Timer-DMA-Circle.png" alt="ADC3"></p><p>The important part is choosing the TIM update event as a trigger. And the configuration of TIM please look back to <em><strong><span style="color: red">Section one: ADC+TIM</span></strong></em> . Then is the configuration of DMA which is configured as circle mode.</p><p><img src="/img/STM32H723-ADC/ADC3-DMA.png" alt="ADC3-DMA"></p><p><em><strong><span style="color: red; font-size: 20px">Attention!</span></strong></em> . You need to ensure the data width is <em><strong><span style="color: red">Half-word</span></strong></em> which is referred to <em><strong><span style="color: red">uint16_t</span></strong></em> . If you want to use <em><strong><span style="color: red">Word</span></strong></em> as you data width then you need to use <em><strong><span style="color: red">uint32_t</span></strong></em> as the size you list of data used.</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> ADC + TIM + DMA </tag>
            
            <tag> ADC + TIM </tag>
            
            <tag> ADC + DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LanQiao Baseboard Development&#39;s log03</title>
      <link href="/2024/11/22/LanQiao_Baseboard_04/ADC-Single-Conversion/"/>
      <url>/2024/11/22/LanQiao_Baseboard_04/ADC-Single-Conversion/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LanQiao </tag>
            
            <tag> STM32 </tag>
            
            <tag> ADC </tag>
            
            <tag> Single-Conversion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LanQiao Baseboard Development&#39;s log03</title>
      <link href="/2024/11/21/LanQiao_Baseboard_03/PWM_InputCapture/"/>
      <url>/2024/11/21/LanQiao_Baseboard_03/PWM_InputCapture/</url>
      
        <content type="html"><![CDATA[<h1 id="LanQiao-Baseboard-development’s-log-03"><a href="#LanQiao-Baseboard-development’s-log-03" class="headerlink" title="LanQiao Baseboard development’s log 03"></a><em><strong>LanQiao Baseboard development’s log 03</strong></em></h1><h2 id="PWM-Input-Capture-Mode-for-Frequency-and-Duty-Calculation"><a href="#PWM-Input-Capture-Mode-for-Frequency-and-Duty-Calculation" class="headerlink" title="PWM Input Capture Mode for Frequency and Duty Calculation"></a><em><strong>PWM Input Capture Mode for Frequency and Duty Calculation</strong></em></h2><h3 id="What-is-PWM-Input-Capture-Mode"><a href="#What-is-PWM-Input-Capture-Mode" class="headerlink" title="What is PWM Input Capture Mode"></a><em><strong>What is PWM Input Capture Mode</strong></em></h3><p>PWM input capture mode, is a special mode of TIM, which is especially useful in frequency measure. But you can’t use it occasionally because it needs a PWM input. Its original theory is below.</p><p><img src="/img/LanQiao-Baseboard03/LanQiao_Baseboard03_theory.png" alt="Theory"></p><h3 id="How-Can-We-Configure-the-Input-Capture-Mode"><a href="#How-Can-We-Configure-the-Input-Capture-Mode" class="headerlink" title="How Can We Configure the Input Capture Mode"></a><em><strong>How Can We Configure the Input Capture Mode</strong></em></h3><p>You should start the TIM input capture and rewrite the callback function. The original theory is when Timer detect the rising edge of PWM signal and then set the TIM counter to zero(Init). When the Timer check the falling edge, the TIM channel will store the counter values. So if Timer detect the second rising edge of PWM, you can read the value of channels which detect the rising edge and the falling edge.</p><p>As the counter values refer to the time between two rising edge, which means the time of a whole period, and the values between the first rising edge and falling edge is the time of high level. Based on the knowledge above, you can exactly understand how can we calculate the frequency and duty of PWM.</p><p>What’s more is that once you get the second rising edge values, you should set the counter of TIM to zeros and restart TIM input capture. And the configuration of TIM is as followed.</p><p><img src="/img/LanQiao-Baseboard03/LanQiao_Baseboard03_configure.png" alt="Configuration"></p><p>First, you need to select the source clock and select two channel, one is direct mode and the other is indirect mode. The counter value should be as large as possible because if the signal frequency is low and the counter value between two rising edge is very large, the second rising edge counter value may be smaller than the first one as the counter reloaded.</p><p>Second, you need to configure the indirect mode channel to falling edge to calculate the duty of PWM.</p><h3 id="How-to-Write-the-Code-of-PWM-Input-Capture"><a href="#How-to-Write-the-Code-of-PWM-Input-Capture" class="headerlink" title="How to Write the Code of PWM Input Capture"></a><em><strong>How to Write the Code of PWM Input Capture</strong></em></h3><p>Simply, you need to enable the TIM Channel.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1);</span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2);</span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);</span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_2);</span><br></pre></td></tr></table></figure><p>Then, you should rewrite the TIM IC CallBack function. You can define the read-counter values as followed.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Is_first_IC1 = <span class="number">1</span>;      <span class="comment">// Whether is firstly capture</span></span><br><span class="line"><span class="type">bool</span> Is_first_IC2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> fir_count1 = <span class="number">0</span>;    <span class="comment">// The first IC TIM</span></span><br><span class="line"><span class="type">uint32_t</span> down_count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> sec_count1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> fir_count2 = <span class="number">0</span>;    <span class="comment">// The second IC TIM</span></span><br><span class="line"><span class="type">uint32_t</span> down_count2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> sec_count2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>And then is the main function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;Instance == TIM2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1)</span><br><span class="line">    &#123;</span><br><span class="line">      fir_count1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);</span><br><span class="line">      sec_count1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);</span><br><span class="line">      __HAL_TIM_SetCounter(htim, <span class="number">0</span>);</span><br><span class="line">      HAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_1);</span><br><span class="line">      HAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;Instance == TIM3)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1)</span><br><span class="line">    &#123;</span><br><span class="line">      fir_count2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);</span><br><span class="line">      sec_count2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);  <span class="comment">// store when captured at falling edge</span></span><br><span class="line">      __HAL_TIM_SetCounter(htim, <span class="number">0</span>);</span><br><span class="line">      HAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_1);</span><br><span class="line">      HAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the theory mentioned above shows, if the callback is from Channel 1(rising edge), read the values and reset the counter values. <span style="color: red; font-size: 20px">But Attention!</span> This code doesn’t care about the problem that if the frequency of signal is low and the counter value of the rising edge is smaller than the one of falling edge.</p><p>As for the duty, you can simply get it by dividing the rising edge value with the falling edge value.<br>$$ Freq &#x3D; \frac{F_{TIM}}{Counter_{fir}}$$<br>$$ Duty &#x3D; \frac{Counter_{sec}}{Counter_{fir}} $$</p><p>That is the whole content of PWM input capture. Thanks for watching!</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LanQiao </tag>
            
            <tag> STM32 </tag>
            
            <tag> PWM Input-Capture </tag>
            
            <tag> TIM direct&amp;Indirect Mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LanQiao Baseboard Development&#39;s log02</title>
      <link href="/2024/11/20/LanQiao_Baseboard_02/PWM-Output/"/>
      <url>/2024/11/20/LanQiao_Baseboard_02/PWM-Output/</url>
      
        <content type="html"><![CDATA[<h1 id="LanQiao-Baseboard-development’s-log-02"><a href="#LanQiao-Baseboard-development’s-log-02" class="headerlink" title="LanQiao Baseboard development’s log 02"></a><em><strong>LanQiao Baseboard development’s log 02</strong></em></h1><h2 id="PWM-Output-with-Changeable-Duty"><a href="#PWM-Output-with-Changeable-Duty" class="headerlink" title="PWM Output with Changeable Duty"></a><em><strong>PWM Output with Changeable Duty</strong></em></h2><h3 id="PWM-Generate-and-Output"><a href="#PWM-Generate-and-Output" class="headerlink" title="PWM Generate and Output"></a><em><strong>PWM Generate and Output</strong></em></h3><p>PWM, simply regarded as square signal, is important in many aspects like motor driven or any thing that can change effect by the level of voltage. So how can we generate a PWM signal? </p><p>We can easily generate a PWM signal through our STM32’s TIM modules. The basic configure that you need to change is:</p><ul><li>First, Activate the TIM and choose a channel as PWM output channel. <span style="color: red; font-size: 20px">Attention!</span> You need to choose CHx rather CHxN which means the reverse of a normal signal. It will output low voltage when a normal PWM output high voltage.</li><li>Second, You should set the prescaler value and counter value. The TIM’s frequency is determined by the prescaler values, and the freq is $F_{pres} &#x3D; \frac{F_{main}}{prescaler+1}$. And the real freq of TIM you choosed is the frequency of prescaler divided by the counter value plus one. $F &#x3D; \frac{F_{pres}}{counter + 1}$.</li><li>Third, the counter means how many count in one period. So you can set the pulse value which should be smaller than the counter because the value $\frac{pulse}{counter}$ is the duty of the PWM.</li></ul><p>Above all is the basic configure of PWM settings.<br><img src="/img/LanQiao-Baseboard02/LanQiao_Baseboard02_configure.png" alt="PWM Configure"></p><h3 id="Code-and-Application-for-PWM"><a href="#Code-and-Application-for-PWM" class="headerlink" title="Code and Application for PWM"></a><em><strong>Code and Application for PWM</strong></em></h3><p>To start TIM channel to output PWM with certain duty, you only need to start TIM with one code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htim16, TIM_CHANNEL_1);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim17, TIM_CHANNEL_1);</span><br></pre></td></tr></table></figure><p>Here is two channels’ PWM output with different TIM and channels.</p><p>And now,let’s talk about ‘Duty’. What is duty and why is duty important? How can we change the duty of PWM generated by TIM.<br>Duty, is the percentage of high level in the total duration. As we all know that the capacity of driven is determined by high level, so if the duty gets larger, then the capacity is stronger, which means the LED will be lighter or the motor will rotate faster.<br>If you want change the lightness or the speed of cars, you can change the duty to achieve this. So how can we change it? We can change duty of certain TIM and certain channel by:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htim16, TIM_CHANNEL_1, pwm1_duty);</span><br></pre></td></tr></table></figure><p>Param:</p><ul><li>&amp;htimx : The TIM of your PWM channel</li><li>TIM_CHANNEL_x : The Channel of your PWM</li><li>pwmx_duty : the duty you want to set. Must smaller than the counter values.</li></ul><p>You can define the values of different PWM output channels and apply key event to change duty. The exact code is as followed.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (keys[<span class="number">1</span>].Ispress)</span><br><span class="line">&#123;</span><br><span class="line">    pwm1_duty += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (pwm1_duty &gt; <span class="number">90</span>) pwm1_duty = <span class="number">10</span>;</span><br><span class="line">    __HAL_TIM_SetCompare(&amp;htim16, TIM_CHANNEL_1, pwm1_duty);</span><br><span class="line">    keys[<span class="number">1</span>].Ispress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (keys[<span class="number">2</span>].Ispress)</span><br><span class="line">&#123;</span><br><span class="line">    pwm2_duty += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (pwm2_duty &gt; <span class="number">90</span>) pwm2_duty = <span class="number">10</span>;</span><br><span class="line">    __HAL_TIM_SetCompare(&amp;htim17, TIM_CHANNEL_1, pwm2_duty);</span><br><span class="line">    keys[<span class="number">2</span>].Ispress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How keys function with this code you can read the <a href="https://locklve.github.io/2024/11/18/LanQiao_Baseboard_01/LED&LCD&Key-development/">last blog’s pt.3</a>. And due to the counter we set to 100, the duty(pulse) must be smaller than 100. And we concern about the death zone problem, which may cause low driven power problems, so we set the duty from 10 percentage to 90 percentage.</p><p>Moreover, we can achieve breathing LED by provide LED PWM with changed duty from low to high and from high to low.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pwm_number == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (pwm1_duty = <span class="number">10</span>; pwm1_duty &lt; <span class="number">90</span>; pwm1_duty++)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim16, TIM_CHANNEL_1, pwm1_duty);</span><br><span class="line">        HAL_Delay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pwm1_duty = <span class="number">90</span>; pwm1_duty &gt; <span class="number">10</span>; pwm1_duty--)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim16, TIM_CHANNEL_1, pwm1_duty);</span><br><span class="line">        HAL_Delay(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The purpose of delay is to make the light of different duty visualize. And you can try the same code on motor, which effect is speeding up then slowing down.</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LanQiao </tag>
            
            <tag> STM32 </tag>
            
            <tag> PWM Output </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LanQiao Baseboard Development&#39;s log01</title>
      <link href="/2024/11/18/LanQiao_Baseboard_01/LED&amp;LCD&amp;Key-development/"/>
      <url>/2024/11/18/LanQiao_Baseboard_01/LED&amp;LCD&amp;Key-development/</url>
      
        <content type="html"><![CDATA[<h1 id="LanQiao-Baseboard-development’s-log-01"><a href="#LanQiao-Baseboard-development’s-log-01" class="headerlink" title="LanQiao Baseboard development’s log 01"></a>LanQiao Baseboard development’s log 01</h1><h2 id="LED、LCD-and-Key-quick-start"><a href="#LED、LCD-and-Key-quick-start" class="headerlink" title="LED、LCD and Key quick start"></a>LED、LCD and Key quick start</h2><h3 id="LED-LED-Display-and-Floating"><a href="#LED-LED-Display-and-Floating" class="headerlink" title="LED - LED Display and Floating"></a>LED - LED Display and Floating</h3><p><strong><em>The Pins to LED is show as followed.</em></strong><br><a href="/img/pin.png">Pins</a></p><p><strong><em>Due to The pin from PC8 to PC15 is used by both LED and LCD so there is D1 between pins and LEDs so that when PD2 is set to High, the value of pins can be also set to LED. Instead, if the PD2 is set to low, the value of pins only affect the LCD’s value.<br>So now we define the display function so that we can easily write the value of LED.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsigned char uint8_t</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Disp</span><span class="params">(<span class="type">uint8_t</span> disLED)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET);   <span class="comment">// Turn off all the led</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, disLED&lt;&lt;<span class="number">8</span>, GPIO_PIN_RESET);    <span class="comment">// Choose led(low 8th switch to high 8th) and turn on</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);     <span class="comment">// Set PD2 to high to enable D1(Lock)</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);   <span class="comment">// ...........low to disable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>The main concept is:</em></strong><br><em><strong>First, Set the values of all pin which control the LED. Then set the PD2 to <span style="color:red; font-size:20px">High</span>. After that, lock down the value so that you can easily operate the LCD rather influence the LED.</strong></em></p><p><strong><em>Now, you can use the display function to create a floating mode.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LED_Float</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 0000 0001 -&gt; 0000 0010 ...etc. If i = 1000 0000 Display the last time and exit.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">0xf0</span>; i = i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LED_Disp(i);</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">    LED_Disp(<span class="number">0x00</span>);     <span class="comment">// Clear the last LED</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Floating, which means that the eight LED turn on and off one by one to make it looks like floating, requires controlling the LED’s sequence. You can write like:</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_x, GPIO_PIN_SET);</span><br></pre></td></tr></table></figure><p><strong><em>and control its time sequence by yourselves but your code will become long and ugly. So this blog use the bit shift combine with loop. As you can see, the GPIO_Port such as GPIOC contains 16 pins, from PC0 to PC15.</em></strong></p><p><strong><em>And the number we can display in binary system:</em></strong></p><table><thead><tr><th>Col1</th><th>Col2</th></tr></thead><tbody><tr><td><strong><em>GPIO_PIN_0</em></strong></td><td><strong><em>GPIO_PIN_15</em></strong></td></tr><tr><td>0000 0000 0000 0001</td><td>1000 0000 0000 0000</td></tr></tbody></table><p><strong><em>In this way, I believe you can easily get to know why we can shift the bit(left side) to make each LED turn on. The PC0 refers to 0x01 and the PC15 refers to 0xf0. Everytime we want to turn the LED0~7 on, we only need to set the bits value that in the low eight position because we carry it to high eight position in our display function.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, disLED&lt;&lt;<span class="number">8</span>, GPIO_PIN_RESET);    <span class="comment">// Choose led(low 8th switch to high 8th) and turn on</span></span><br></pre></td></tr></table></figure><p><strong><em>Then you can adjust the time of turning on to reach the final result you want. You can use the basic display function and the concept to generate your own display mode.</em></strong></p><h3 id="LCD-Display-and-show-Info"><a href="#LCD-Display-and-show-Info" class="headerlink" title="LCD - Display and show Info"></a>LCD - Display and show Info</h3><p><strong><em>The LCD original code is complex and difficult but it is lucky that we have the driver lib so all we need to do is transport it and use it.</em></strong></p><p><strong><em>In this blog we will support you with the driver lib file code and some most-use function with using tips.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br></pre></td><td class="code"><pre><span class="line">/-----Driver Lib-----/</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Fonts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span>  vu16 TextColor = <span class="number">0x0000</span>, BackColor = <span class="number">0xFFFF</span>;</span><br><span class="line">vu16 dummy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : Delay_LCD</span></span><br><span class="line"><span class="comment">* Description    : Inserts a delay time.</span></span><br><span class="line"><span class="comment">* Input          : nCount: specifies the delay time length.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_LCD</span><span class="params">(u16 n)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3000</span>; ++j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">uC8230��Һ���������Ĵ�������</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">REG_8230_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0000</span>, <span class="number">0x0001</span>);</span><br><span class="line">    Delay_LCD(<span class="number">1000</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0001</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0010</span>, <span class="number">0x1790</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0060</span>, <span class="number">0x2700</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0061</span>, <span class="number">0x0001</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0046</span>, <span class="number">0x0002</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0013</span>, <span class="number">0x8010</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0012</span>, <span class="number">0x80fe</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0002</span>, <span class="number">0x0500</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0003</span>, <span class="number">0x1030</span>);</span><br><span class="line"></span><br><span class="line">    LCD_WriteReg(<span class="number">0x0030</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0031</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0032</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0033</span>, <span class="number">0x0300</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0034</span>, <span class="number">0x0003</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0035</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0036</span>, <span class="number">0x0014</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0037</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0038</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0039</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x003a</span>, <span class="number">0x0300</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x003b</span>, <span class="number">0x0003</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x003c</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x003d</span>, <span class="number">0x1400</span>);</span><br><span class="line"></span><br><span class="line">    LCD_WriteReg(<span class="number">0x0092</span>, <span class="number">0x0200</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0093</span>, <span class="number">0x0303</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0090</span>, <span class="number">0x080d</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0003</span>, <span class="number">0x1018</span>);</span><br><span class="line">    LCD_WriteReg(<span class="number">0x0007</span>, <span class="number">0x0173</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">REG_932X_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(R227, <span class="number">0x3008</span>);   <span class="comment">// Set internal timing</span></span><br><span class="line">    LCD_WriteReg(R231, <span class="number">0x0012</span>); <span class="comment">// Set internal timing</span></span><br><span class="line">    LCD_WriteReg(R239, <span class="number">0x1231</span>);   <span class="comment">// Set internal timing</span></span><br><span class="line">    LCD_WriteReg(R1, <span class="number">0x0000</span>);   <span class="comment">// set SS and SM bit  //0x0100</span></span><br><span class="line">    LCD_WriteReg(R2, <span class="number">0x0700</span>);   <span class="comment">// set 1 line inversion</span></span><br><span class="line">    LCD_WriteReg(R3, <span class="number">0x1030</span>);     <span class="comment">// set GRAM write direction and BGR=1.</span></span><br><span class="line">    LCD_WriteReg(R4, <span class="number">0x0000</span>);     <span class="comment">// Resize register</span></span><br><span class="line">    LCD_WriteReg(R8, <span class="number">0x0207</span>);     <span class="comment">// set the back porch and front porch</span></span><br><span class="line">    LCD_WriteReg(R9, <span class="number">0x0000</span>);     <span class="comment">// set non-display area refresh cycle ISC[3:0]</span></span><br><span class="line">    LCD_WriteReg(R10, <span class="number">0x0000</span>);    <span class="comment">// FMARK function</span></span><br><span class="line">    LCD_WriteReg(R12, <span class="number">0x0000</span>);  <span class="comment">// RGB interface setting</span></span><br><span class="line">    LCD_WriteReg(R13, <span class="number">0x0000</span>);    <span class="comment">// Frame marker Position</span></span><br><span class="line">    LCD_WriteReg(R15, <span class="number">0x0000</span>);  <span class="comment">// RGB interface polarity</span></span><br><span class="line">    <span class="comment">/**************Power On sequence ****************/</span></span><br><span class="line">    LCD_WriteReg(R16, <span class="number">0x0000</span>);    <span class="comment">// SAP, BT[3:0], AP, DSTB, SLP, STB</span></span><br><span class="line">    LCD_WriteReg(R17, <span class="number">0x0007</span>);    <span class="comment">// DC1[2:0], DC0[2:0], VC[2:0]</span></span><br><span class="line">    LCD_WriteReg(R18, <span class="number">0x0000</span>);  <span class="comment">// VREG1OUT voltage</span></span><br><span class="line">    LCD_WriteReg(R19, <span class="number">0x0000</span>);    <span class="comment">// VDV[4:0] for VCOM amplitude</span></span><br><span class="line">    <span class="comment">//Delay_Ms(200);                    // Delay 200 MS , Dis-charge capacitor power voltage</span></span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line">    LCD_WriteReg(R16, <span class="number">0x1690</span>);    <span class="comment">// SAP, BT[3:0], AP, DSTB, SLP, STB</span></span><br><span class="line">    LCD_WriteReg(R17, <span class="number">0x0227</span>);  <span class="comment">// R11H=0x0221 at VCI=3.3V, DC1[2:0], DC0[2:0], VC[2:0]</span></span><br><span class="line">    <span class="comment">//Delay_Ms(50);      // Delay 50ms</span></span><br><span class="line">    HAL_Delay(<span class="number">50</span>);</span><br><span class="line">    LCD_WriteReg(R18, <span class="number">0x001D</span>);  <span class="comment">// External reference voltage= Vci;</span></span><br><span class="line">    <span class="comment">//Delay_Ms(50);      // Delay 50ms</span></span><br><span class="line">    HAL_Delay(<span class="number">50</span>);</span><br><span class="line">    LCD_WriteReg(R19, <span class="number">0x0800</span>);  <span class="comment">// R13H=1D00 when R12H=009D;VDV[4:0] for VCOM amplitude</span></span><br><span class="line">    LCD_WriteReg(R41, <span class="number">0x0014</span>);  <span class="comment">// R29H=0013 when R12H=009D;VCM[5:0] for VCOMH</span></span><br><span class="line">    LCD_WriteReg(R43, <span class="number">0x000B</span>);    <span class="comment">// Frame Rate = 96Hz</span></span><br><span class="line">    <span class="comment">//Delay_Ms(50);      // Delay 50ms</span></span><br><span class="line">    HAL_Delay(<span class="number">50</span>);</span><br><span class="line">    LCD_WriteReg(R32, <span class="number">0x0000</span>);  <span class="comment">// GRAM horizontal Address</span></span><br><span class="line">    LCD_WriteReg(R33, <span class="number">0x0000</span>);  <span class="comment">// GRAM Vertical Address</span></span><br><span class="line">    <span class="comment">/* ----------- Adjust the Gamma Curve ---------- */</span></span><br><span class="line">    LCD_WriteReg(R48, <span class="number">0x0007</span>);</span><br><span class="line">    LCD_WriteReg(R49, <span class="number">0x0707</span>);</span><br><span class="line">    LCD_WriteReg(R50, <span class="number">0x0006</span>);</span><br><span class="line">    LCD_WriteReg(R53, <span class="number">0x0704</span>);</span><br><span class="line">    LCD_WriteReg(R54, <span class="number">0x1F04</span>);</span><br><span class="line">    LCD_WriteReg(R55, <span class="number">0x0004</span>);</span><br><span class="line">    LCD_WriteReg(R56, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R57, <span class="number">0x0706</span>);</span><br><span class="line">    LCD_WriteReg(R60, <span class="number">0x0701</span>);</span><br><span class="line">    LCD_WriteReg(R61, <span class="number">0x000F</span>);</span><br><span class="line">    <span class="comment">/* ------------------ Set GRAM area --------------- */</span></span><br><span class="line">    LCD_WriteReg(R80, <span class="number">0x0000</span>);    <span class="comment">// Horizontal GRAM Start Address</span></span><br><span class="line">    LCD_WriteReg(R81, <span class="number">0x00EF</span>);    <span class="comment">// Horizontal GRAM End Address</span></span><br><span class="line">    LCD_WriteReg(R82, <span class="number">0x0000</span>);  <span class="comment">// Vertical GRAM Start Address</span></span><br><span class="line">    LCD_WriteReg(R83, <span class="number">0x013F</span>);  <span class="comment">// Vertical GRAM Start Address</span></span><br><span class="line">    LCD_WriteReg(R96, <span class="number">0x2700</span>);  <span class="comment">// Gate Scan Line  0xA700</span></span><br><span class="line">    LCD_WriteReg(R97, <span class="number">0x0001</span>);  <span class="comment">// NDL,VLE, REV</span></span><br><span class="line">    LCD_WriteReg(R106, <span class="number">0x0000</span>); <span class="comment">// set scrolling line</span></span><br><span class="line">    <span class="comment">/* -------------- Partial Display Control --------- */</span></span><br><span class="line">    LCD_WriteReg(R128, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R129, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R130, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R131, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R132, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R133, <span class="number">0x0000</span>);</span><br><span class="line">    <span class="comment">/* -------------- Panel Control ------------------- */</span></span><br><span class="line">    LCD_WriteReg(R144, <span class="number">0x0010</span>);</span><br><span class="line">    LCD_WriteReg(R146, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R147, <span class="number">0x0003</span>);</span><br><span class="line">    LCD_WriteReg(R149, <span class="number">0x0110</span>);</span><br><span class="line">    LCD_WriteReg(R151, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R152, <span class="number">0x0000</span>);</span><br><span class="line">    <span class="comment">/* Set GRAM write direction and BGR = 1 */</span></span><br><span class="line">    <span class="comment">/* I/D=01 (Horizontal : increment, Vertical : decrement) */</span></span><br><span class="line">    <span class="comment">/* AM=1 (address is updated in vertical writing direction) */</span></span><br><span class="line">    LCD_WriteReg(R3, <span class="number">0x01018</span>);    <span class="comment">//0x1018</span></span><br><span class="line"></span><br><span class="line">    LCD_WriteReg(R7, <span class="number">0x0173</span>);   <span class="comment">// 262K color and display ON</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : STM3210B_LCD_Init</span></span><br><span class="line"><span class="comment">* Description    : Initializes the LCD.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_CtrlLinesConfig();</span><br><span class="line">    dummy = LCD_ReadReg(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dummy == <span class="number">0x8230</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        REG_8230_Init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        REG_932X_Init();</span><br><span class="line">    &#125;</span><br><span class="line">    dummy = LCD_ReadReg(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_SetTextColor</span></span><br><span class="line"><span class="comment">* Description    : Sets the Text color.</span></span><br><span class="line"><span class="comment">* Input          : - Color: specifies the Text color code RGB(5-6-5).</span></span><br><span class="line"><span class="comment">* Output         : - TextColor: Text color global variable used by LCD_DrawChar</span></span><br><span class="line"><span class="comment">*                  and LCD_DrawPicture functions.</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetTextColor</span><span class="params">(vu16 Color)</span></span><br><span class="line">&#123;</span><br><span class="line">    TextColor = Color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_SetBackColor</span></span><br><span class="line"><span class="comment">* Description    : Sets the Background color.</span></span><br><span class="line"><span class="comment">* Input          : - Color: specifies the Background color code RGB(5-6-5).</span></span><br><span class="line"><span class="comment">* Output         : - BackColor: Background color global variable used by</span></span><br><span class="line"><span class="comment">*                  LCD_DrawChar and LCD_DrawPicture functions.</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetBackColor</span><span class="params">(vu16 Color)</span></span><br><span class="line">&#123;</span><br><span class="line">    BackColor = Color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_ClearLine</span></span><br><span class="line"><span class="comment">* Description    : Clears the selected line.</span></span><br><span class="line"><span class="comment">* Input          : - Line: the Line to be cleared.</span></span><br><span class="line"><span class="comment">*                    This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">*                       - Linex: where x can be 0..9</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ClearLine</span><span class="params">(u8 Line)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_DisplayStringLine(Line, <span class="string">&quot;                    &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_Clear</span></span><br><span class="line"><span class="comment">* Description    : Clears the hole LCD.</span></span><br><span class="line"><span class="comment">* Input          : Color: the color of the background.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Clear</span><span class="params">(u16 Color)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 index = <span class="number">0</span>;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteRAM(Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_SetCursor</span></span><br><span class="line"><span class="comment">* Description    : Sets the cursor position.</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: specifies the X position.</span></span><br><span class="line"><span class="comment">*                  - Ypos: specifies the Y position.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(u8 Xpos, u16 Ypos)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(R32, Xpos);</span><br><span class="line">    LCD_WriteReg(R33, Ypos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawChar</span></span><br><span class="line"><span class="comment">* Description    : Draws a character on LCD.</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: the Line where to display the character shape.</span></span><br><span class="line"><span class="comment">*                    This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">*                       - Linex: where x can be 0..9</span></span><br><span class="line"><span class="comment">*                  - Ypos: start column address.</span></span><br><span class="line"><span class="comment">*                  - c: pointer to the character data.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawChar</span><span class="params">(u8 Xpos, u16 Ypos, uc16 *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    u8 Xaddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Xaddress = Xpos;</span><br><span class="line">    LCD_SetCursor(Xaddress, Ypos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">24</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((c[index] &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0x00</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LCD_WriteRAM(BackColor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LCD_WriteRAM(TextColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Xaddress++;</span><br><span class="line">        LCD_SetCursor(Xaddress, Ypos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DisplayChar</span></span><br><span class="line"><span class="comment">* Description    : Displays one character (16dots width, 24dots height).</span></span><br><span class="line"><span class="comment">* Input          : - Line: the Line where to display the character shape .</span></span><br><span class="line"><span class="comment">*                    This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">*                       - Linex: where x can be 0..9</span></span><br><span class="line"><span class="comment">*                  - Column: start column address.</span></span><br><span class="line"><span class="comment">*                  - Ascii: character ascii code, must be between 0x20 and 0x7E.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DisplayChar</span><span class="params">(u8 Line, u16 Column, u8 Ascii)</span></span><br><span class="line">&#123;</span><br><span class="line">    Ascii -= <span class="number">32</span>;</span><br><span class="line">    LCD_DrawChar(Line, Column, &amp;ASCII_Table[Ascii * <span class="number">24</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DisplayStringLine</span></span><br><span class="line"><span class="comment">* Description    : Displays a maximum of 20 char on the LCD.</span></span><br><span class="line"><span class="comment">* Input          : - Line: the Line where to display the character shape .</span></span><br><span class="line"><span class="comment">*                    This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">*                       - Linex: where x can be 0..9</span></span><br><span class="line"><span class="comment">*                  - *ptr: pointer to string to display on LCD.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DisplayStringLine</span><span class="params">(u8 Line, u8 *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 i = <span class="number">0</span>;</span><br><span class="line">    u16 refcolumn = <span class="number">319</span>;<span class="comment">//319;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((*ptr != <span class="number">0</span>) &amp;&amp; (i &lt; <span class="number">20</span>)) <span class="comment">//20</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD_DisplayChar(Line, refcolumn, *ptr);</span><br><span class="line">        refcolumn -= <span class="number">16</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_SetDisplayWindow</span></span><br><span class="line"><span class="comment">* Description    : Sets a display window</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: specifies the X buttom left position.</span></span><br><span class="line"><span class="comment">*                  - Ypos: specifies the Y buttom left position.</span></span><br><span class="line"><span class="comment">*                  - Height: display window height.</span></span><br><span class="line"><span class="comment">*                  - Width: display window width.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetDisplayWindow</span><span class="params">(u8 Xpos, u16 Ypos, u8 Height, u16 Width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Xpos &gt;= Height)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteReg(R80, (Xpos - Height + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteReg(R80, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LCD_WriteReg(R81, Xpos);</span><br><span class="line">    <span class="keyword">if</span>(Ypos &gt;= Width)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteReg(R82, (Ypos - Width + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteReg(R82, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Vertical GRAM End Address */</span></span><br><span class="line">    LCD_WriteReg(R83, Ypos);</span><br><span class="line">    LCD_SetCursor(Xpos, Ypos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_WindowModeDisable</span></span><br><span class="line"><span class="comment">* Description    : Disables LCD Window mode.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WindowModeDisable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_SetDisplayWindow(<span class="number">239</span>, <span class="number">0x13F</span>, <span class="number">240</span>, <span class="number">320</span>);</span><br><span class="line">    LCD_WriteReg(R3, <span class="number">0x1018</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawLine</span></span><br><span class="line"><span class="comment">* Description    : Displays a line.</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: specifies the X position.</span></span><br><span class="line"><span class="comment">*                  - Ypos: specifies the Y position.</span></span><br><span class="line"><span class="comment">*                  - Length: line length.</span></span><br><span class="line"><span class="comment">*                  - Direction: line direction.</span></span><br><span class="line"><span class="comment">*                    This parameter can be one of the following values: Vertical</span></span><br><span class="line"><span class="comment">*                    or Horizontal.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawLine</span><span class="params">(u8 Xpos, u16 Ypos, u16 Length, u8 Direction)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LCD_SetCursor(Xpos, Ypos);</span><br><span class="line">    <span class="keyword">if</span>(Direction == Horizontal)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LCD_WriteRAM(TextColor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">            LCD_WriteRAM(TextColor);</span><br><span class="line">            Xpos++;</span><br><span class="line">            LCD_SetCursor(Xpos, Ypos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawRect</span></span><br><span class="line"><span class="comment">* Description    : Displays a rectangle.</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: specifies the X position.</span></span><br><span class="line"><span class="comment">*                  - Ypos: specifies the Y position.</span></span><br><span class="line"><span class="comment">*                  - Height: display rectangle height.</span></span><br><span class="line"><span class="comment">*                  - Width: display rectangle width.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawRect</span><span class="params">(u8 Xpos, u16 Ypos, u8 Height, u16 Width)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_DrawLine(Xpos, Ypos, Width, Horizontal);</span><br><span class="line">    LCD_DrawLine((Xpos + Height), Ypos, Width, Horizontal);</span><br><span class="line"></span><br><span class="line">    LCD_DrawLine(Xpos, Ypos, Height, Vertical);</span><br><span class="line">    LCD_DrawLine(Xpos, (Ypos - Width + <span class="number">1</span>), Height, Vertical);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawCircle</span></span><br><span class="line"><span class="comment">* Description    : Displays a circle.</span></span><br><span class="line"><span class="comment">* Input          : - Xpos: specifies the X position.</span></span><br><span class="line"><span class="comment">*                  - Ypos: specifies the Y position.</span></span><br><span class="line"><span class="comment">*                  - Height: display rectangle height.</span></span><br><span class="line"><span class="comment">*                  - Width: display rectangle width.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawCircle</span><span class="params">(u8 Xpos, u16 Ypos, u16 Radius)</span></span><br><span class="line">&#123;</span><br><span class="line">    s32  D;</span><br><span class="line">    u32  CurX;</span><br><span class="line">    u32  CurY;</span><br><span class="line"></span><br><span class="line">    D = <span class="number">3</span> - (Radius &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    CurX = <span class="number">0</span>;</span><br><span class="line">    CurY = Radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (CurX &lt;= CurY)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_SetCursor(Xpos + CurX, Ypos + CurY);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos + CurX, Ypos - CurY);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos - CurX, Ypos + CurY);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos - CurX, Ypos - CurY);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos + CurY, Ypos + CurX);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos + CurY, Ypos - CurX);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos - CurY, Ypos + CurX);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        LCD_SetCursor(Xpos - CurY, Ypos - CurX);</span><br><span class="line">        LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">        LCD_WriteRAM(TextColor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            D += (CurX &lt;&lt; <span class="number">2</span>) + <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            D += ((CurX - CurY) &lt;&lt; <span class="number">2</span>) + <span class="number">10</span>;</span><br><span class="line">            CurY--;</span><br><span class="line">        &#125;</span><br><span class="line">        CurX++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawMonoPict</span></span><br><span class="line"><span class="comment">* Description    : Displays a monocolor picture.</span></span><br><span class="line"><span class="comment">* Input          : - Pict: pointer to the picture array.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawMonoPict</span><span class="params">(uc32 *Pict)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LCD_SetCursor(<span class="number">0</span>, <span class="number">319</span>);</span><br><span class="line"></span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">2400</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((Pict[index] &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0x00</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LCD_WriteRAM(BackColor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LCD_WriteRAM(TextColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_WriteBMP</span></span><br><span class="line"><span class="comment">* Description    : Displays a bitmap picture loaded in the internal Flash.</span></span><br><span class="line"><span class="comment">* Input          : - BmpAddress: Bmp picture address in the internal Flash.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteBMP</span><span class="params">(u32 BmpAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 index = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = *(vu16 *) (BmpAddress + <span class="number">2</span>);</span><br><span class="line">    size |= (*(vu16 *) (BmpAddress + <span class="number">4</span>)) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    index = *(vu16 *) (BmpAddress + <span class="number">10</span>);</span><br><span class="line">    index |= (*(vu16 *) (BmpAddress + <span class="number">12</span>)) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    size = (size - index) / <span class="number">2</span>;</span><br><span class="line">    BmpAddress += index;</span><br><span class="line"></span><br><span class="line">    LCD_WriteReg(R3, <span class="number">0x1008</span>);</span><br><span class="line">    LCD_WriteRAM_Prepare();</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteRAM(*(vu16 *)BmpAddress);</span><br><span class="line">        BmpAddress += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LCD_WriteReg(R3, <span class="number">0x1018</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_WriteReg</span></span><br><span class="line"><span class="comment">* Description    : Writes to the selected LCD register.</span></span><br><span class="line"><span class="comment">* Input          : - LCD_Reg: address of the selected register.</span></span><br><span class="line"><span class="comment">*                  - LCD_RegValue: value to write to the selected register.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteReg</span><span class="params">(u8 LCD_Reg, u16 LCD_RegValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOB-&gt;BRR  |= GPIO_PIN_9;</span><br><span class="line">    GPIOB-&gt;BRR  |= GPIO_PIN_8;</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_5;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = LCD_Reg;</span><br><span class="line">    GPIOB-&gt;BRR  |= GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_8;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = LCD_RegValue;</span><br><span class="line">    GPIOB-&gt;BRR  |= GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_ReadReg</span></span><br><span class="line"><span class="comment">* Description    : Reads the selected LCD Register.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : LCD Register Value.</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line">u16 <span class="title function_">LCD_ReadReg</span><span class="params">(u8 LCD_Reg)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 temp;</span><br><span class="line"></span><br><span class="line">    GPIOB-&gt;BRR |= GPIO_PIN_9;</span><br><span class="line">    GPIOB-&gt;BRR |= GPIO_PIN_8;</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_5;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = LCD_Reg;</span><br><span class="line">    GPIOB-&gt;BRR |= GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_8;</span><br><span class="line"></span><br><span class="line">    LCD_BusIn();</span><br><span class="line">    GPIOA-&gt;BRR |= GPIO_PIN_8;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    temp = GPIOC-&gt;IDR;</span><br><span class="line">    GPIOA-&gt;BSRR |= GPIO_PIN_8;</span><br><span class="line"></span><br><span class="line">    LCD_BusOut();</span><br><span class="line">    GPIOB-&gt;BSRR |= GPIO_PIN_9;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_WriteRAM_Prepare</span></span><br><span class="line"><span class="comment">* Description    : Prepare to write to the LCD RAM.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteRAM_Prepare</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_9;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_8;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = R34;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_8;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_9;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_WriteRAM</span></span><br><span class="line"><span class="comment">* Description    : Writes to the LCD RAM.</span></span><br><span class="line"><span class="comment">* Input          : - RGB_Code: the pixel color in RGB mode (5-6-5).</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteRAM</span><span class="params">(u16 RGB_Code)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_9;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_8;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = RGB_Code;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_8;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_9;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_ReadRAM</span></span><br><span class="line"><span class="comment">* Description    : Reads the LCD RAM.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : LCD RAM Value.</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line">u16 <span class="title function_">LCD_ReadRAM</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 temp;</span><br><span class="line"></span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_9;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_8;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;ODR = R34;</span><br><span class="line">    GPIOB-&gt;BRR  |=  GPIO_PIN_5;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_5;</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_8;</span><br><span class="line"></span><br><span class="line">    LCD_BusIn();</span><br><span class="line">    GPIOA-&gt;BRR |=  GPIO_PIN_8;</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    __nop();</span><br><span class="line">    temp = GPIOC-&gt;IDR;</span><br><span class="line">    GPIOA-&gt;BSRR |=  GPIO_PIN_8;</span><br><span class="line"></span><br><span class="line">    LCD_BusOut();</span><br><span class="line">    GPIOB-&gt;BSRR |=  GPIO_PIN_9;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_PowerOn</span></span><br><span class="line"><span class="comment">* Description    : Power on the LCD.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_PowerOn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(R16, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R17, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R18, <span class="number">0x0000</span>);</span><br><span class="line">    LCD_WriteReg(R19, <span class="number">0x0000</span>);</span><br><span class="line">    Delay_LCD(<span class="number">20</span>);</span><br><span class="line">    LCD_WriteReg(R16, <span class="number">0x17B0</span>);</span><br><span class="line">    LCD_WriteReg(R17, <span class="number">0x0137</span>);</span><br><span class="line">    Delay_LCD(<span class="number">5</span>);</span><br><span class="line">    LCD_WriteReg(R18, <span class="number">0x0139</span>);</span><br><span class="line">    Delay_LCD(<span class="number">5</span>);</span><br><span class="line">    LCD_WriteReg(R19, <span class="number">0x1d00</span>);</span><br><span class="line">    LCD_WriteReg(R41, <span class="number">0x0013</span>);</span><br><span class="line">    Delay_LCD(<span class="number">5</span>);</span><br><span class="line">    LCD_WriteReg(R7, <span class="number">0x0173</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DisplayOn</span></span><br><span class="line"><span class="comment">* Description    : Enables the Display.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DisplayOn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(R7, <span class="number">0x0173</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DisplayOff</span></span><br><span class="line"><span class="comment">* Description    : Disables the Display.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DisplayOff</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_WriteReg(R7, <span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_CtrlLinesConfig</span></span><br><span class="line"><span class="comment">* Description    : Configures LCD Control lines.</span></span><br><span class="line"><span class="comment">                   Push-Pull mode.</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_CtrlLinesConfig</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_9;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.Pin =  GPIO_PIN_8 ;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    LCD_BusOut();</span><br><span class="line"></span><br><span class="line">    GPIOA-&gt;BSRR |= <span class="number">0x0100</span>;</span><br><span class="line">    GPIOB-&gt;BSRR |= <span class="number">0x0220</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_BusIn</span></span><br><span class="line"><span class="comment">* Description    : Configures the Parallel interface for LCD(PortC)</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_BusIn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_All;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_BusOut</span></span><br><span class="line"><span class="comment">* Description    : Configures the Parallel interface for LCD(PortC)</span></span><br><span class="line"><span class="comment">* Input          : None</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_BusOut</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_All;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name  : LCD_DrawPicture</span></span><br><span class="line"><span class="comment">* Description    : Displays a 16 color picture.</span></span><br><span class="line"><span class="comment">* Input          : - picture: pointer to the picture array.</span></span><br><span class="line"><span class="comment">* Output         : None</span></span><br><span class="line"><span class="comment">* Return         : None</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawPicture</span><span class="params">(<span class="type">const</span> u8 *picture)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    LCD_SetCursor(<span class="number">0x00</span>, <span class="number">0x0000</span>);</span><br><span class="line"></span><br><span class="line">    LCD_WriteRAM_Prepare(); <span class="comment">/* Prepare to write GRAM */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; index &lt; <span class="number">76800</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_WriteRAM(picture[<span class="number">2</span> * index + <span class="number">1</span>] &lt;&lt; <span class="number">8</span> | picture[<span class="number">2</span> * index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************User Defined Functions********************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">My_LCD_Init</span><span class="params">(u16 Background_Color, vu16 Text_Color)</span></span><br><span class="line">&#123;</span><br><span class="line">  LCD_Init();</span><br><span class="line">  LCD_Clear(Background_Color);</span><br><span class="line">  LCD_SetBackColor(Background_Color);</span><br><span class="line">  LCD_SetTextColor(Text_Color);</span><br><span class="line">  </span><br><span class="line">  LCD_DisplayStringLine(Line0, (<span class="type">uint8_t</span>*)<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  HAL_Delay(<span class="number">5000</span>);</span><br><span class="line">  LCD_Clear(Background_Color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><em>The .h file need you to define by yourselves. And after you add the files’ path and include the .h files, you will be able to use the function and show information, even picture if you like.</em></strong></p><p>Tips:</p><ul><li>The initial background color is white, and we provide a function called <span style="color: red; font-size: 20px">LCD_SetBackColor(vu16 Color)</span> which can set the background of your text to any define color as its default color is white. </li><li>However, when you use this function, you may find out that only the space where you show texts will change its background color. And other place is still white. So you need <span style="color: red; font-size: 20px">LCD_Clear(u16 Color)</span> which can clear and set the whole LCD to one background color. So we usually set color and clear with the color as necessary step for init.</li><li>After you set the background color, you may want to change the text color for better performance. Then you can write <span style="color: red; font-size: 20px">LCD_SetTextColor(vu16 Color)</span>. So that you finish all the basic init step.</li></ul><h3 id="Key-Trigger-mode-and-event"><a href="#Key-Trigger-mode-and-event" class="headerlink" title="Key - Trigger mode and event"></a>Key - Trigger mode and event</h3><p><strong><em>One key bottom contains different trigger mode such as single-press, double-press, long-press and so on. So it is important to define how you memorize keys’ states and judge its trigger event. In this blog, we use structure to store info of key, and the relevant define as followed.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Key</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> long_press;   <span class="comment">// long press check (count times)</span></span><br><span class="line">  <span class="type">uint8_t</span> judge_sta;    <span class="comment">// whether the key is press when last time enter callback(when the key is press)</span></span><br><span class="line">  <span class="type">bool</span> now_key;         <span class="comment">// the key state when enter TIM callback</span></span><br><span class="line">  <span class="type">bool</span> Ispress;         <span class="comment">// Flag of key is pressed</span></span><br><span class="line">&#125;Key;</span><br></pre></td></tr></table></figure><p><strong><em>You need to set a TIM(This blog uses TIM3) and configure its <span style="color: red">Prescaler</span> and <span style="color: red">Period</span> value to make your timer enter interrupt callback function every 10ms(the time between twice key check to eliminate the error caused by key itself) one time.</em></strong></p><p><strong><em>And you need to rewrite the Period elapsed callback function, check and judge the key event in the callback function. The concrete code is below.</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Key keys[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;     <span class="comment">// define a list to store 4 keys&#x27; structure</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// judge which TIMER finish its period(important especially when you have different TIMER callback)</span></span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;Instance == TIM3)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// every 10ms(Timer CallBack time) check key state and update the value of now_key</span></span><br><span class="line">    keys[<span class="number">0</span>].now_key = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0);</span><br><span class="line">    keys[<span class="number">1</span>].now_key = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1);</span><br><span class="line">    keys[<span class="number">2</span>].now_key = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2);</span><br><span class="line">    keys[<span class="number">3</span>].now_key = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for every key judge one time</span></span><br><span class="line">    <span class="comment">// judge 1 times per 10ms (Delay to eliminate the error of key)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (keys[i].judge_sta)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// key wasn&#x27;t press before</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// the first check is pressed.</span></span><br><span class="line">          <span class="keyword">if</span> (keys[i].now_key == <span class="number">0</span>) keys[i].judge_sta = <span class="number">1</span>;  <span class="comment">// this time the key is check press</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key is checked to be pressed last time</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// the second check is also pressed.</span></span><br><span class="line">          <span class="keyword">if</span> (keys[i].now_key == <span class="number">0</span>) </span><br><span class="line">          &#123;</span><br><span class="line">            keys[i].judge_sta = <span class="number">2</span>;</span><br><span class="line">            keys[i].Ispress = <span class="number">1</span>;      <span class="comment">// The key is truly pressed</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// the second check failed. It is an error and init again.</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            keys[i].judge_sta = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (keys[i].now_key == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            keys[i].judge_sta = <span class="number">0</span>;  <span class="comment">// leave the key and return judge&#x27;s value. Start next press check.</span></span><br><span class="line">            <span class="comment">// If want a leave check(one press event when leave key)</span></span><br><span class="line">            <span class="comment">// Write: keys[i].Ispress = 1;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// hold the key</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// judge is 2 unless leave key. The long press is continue plus(limit to 100 -&gt; 1s).</span></span><br><span class="line">            keys[i].long_press++;</span><br><span class="line">            <span class="keyword">if</span> (keys[i].long_press &gt;= <span class="number">100</span>) keys[i].long_press = <span class="number">100</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>The code contains detailed comments which can help you understand how it works. And you can write more judge function with this concept. And the overall method is every 10ms read the keys’ value which is set to high as default.</em></strong></p><p><strong><em>And as judge is 0 at first, all the key will enter the case:0. And then if this time read pin is low which means the key is pressed, it will set judge to 1. When next 10ms enter the callback function, read pins’ state as well, but this time will enter case:1 as judge is set to 1 at the last 10ms.</em></strong></p><p><strong><em>If this time read pin is still low(key pressed), set the judge to 2 and Ispress to 1 which indicate that the key is truly pressed. Else, it indicates that it is an error so reset the judge value to 0. The case:2 means only if you leave the key that you can start next event, which avoid continuously triggering if you hold the key. Also I add a long-press check in the case:2.</em></strong></p><p><strong><em>If you hold the key, the judge is always 2 and enter case:2 every 10ms. In this way, if you enter the case:2, the long_press add one and if you enter for over 100 times we suppose it is a long press and limit it to 100 which means long press.</em></strong></p><p><strong><em>What is more? You can define a clear function to clear the state value after you read the value in main function which is like:</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear_keys</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    keys[i].Ispress = <span class="number">0</span>;</span><br><span class="line">    keys[i].judge_sta = <span class="number">0</span>;</span><br><span class="line">    keys[i].long_press = <span class="number">0</span>;</span><br><span class="line">    keys[i].now_key = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Above is all the content for these three modules. I will start the next study log soon, please wait and see!</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LanQiao </tag>
            
            <tag> STM32 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to quickly start Markdown</title>
      <link href="/2024/11/13/Quick-start-Markdown/"/>
      <url>/2024/11/13/Quick-start-Markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-quickly-start-Markdown-edition"><a href="#How-to-quickly-start-Markdown-edition" class="headerlink" title="How to quickly start Markdown edition"></a><em><strong>How to quickly start Markdown edition</strong></em></h1><h2 id="Text-purpose"><a href="#Text-purpose" class="headerlink" title="Text purpose:"></a><em><strong>Text purpose:</strong></em></h2><p><em><strong>This text is written for those who want to use markdown to edit their posts or reports but have no idea about how to start.<br>Or for people knowing the basic operation of markdown but want to edit a beautiful markdown file. Even you can perceive it file as a memo!</strong></em></p><h2 id="Operation-conclusion"><a href="#Operation-conclusion" class="headerlink" title="Operation conclusion"></a><em><strong>Operation conclusion</strong></em></h2><ul><li><h3 id="Bold-and-Italics"><a href="#Bold-and-Italics" class="headerlink" title="Bold and Italics"></a><em><strong>Bold and Italics</strong></em></h3></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bold -&gt; <span class="strong">**Text here**</span> and Italics -&gt; <span class="emphasis">_Text Here_</span></span><br></pre></td></tr></table></figure><p>And the present effects like <strong>Bold</strong> and <em>Italics</em>. To give more details, you can <em><strong>Nest</strong></em> one another to create <em><strong>Bold and Italics</strong></em> word.</p><ul><li><h3 id="Delete-Line"><a href="#Delete-Line" class="headerlink" title="Delete Line"></a><em><strong>Delete Line</strong></em></h3></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delete line -&gt; ~~Text Here~~</span><br></pre></td></tr></table></figure><p>The effect is like <em><strong><del>Delete text</del></strong></em>. You can use this to emphasize the change from th original or the false it used to be.</p><ul><li><h3 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a><em><strong>Code Block</strong></em></h3></li></ul><p>You can nest code by using:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;<span class="code">```(type) text here```</span>&quot;</span><br></pre></td></tr></table></figure><ul><li><h3 id="Link-and-Image"><a href="#Link-and-Image" class="headerlink" title="Link and Image"></a><em><strong>Link and Image</strong></em></h3></li></ul><p>You can insert <em><strong>Link</strong></em> or <em><strong>Image</strong></em> by:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># insert link </span></span><br><span class="line">[<span class="string">Visit Kimi</span>](<span class="link">https://kimi.ai</span>) -&gt; [<span class="string">explain your link</span>](<span class="link">https://website.link.here</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># insert image</span></span><br><span class="line">![<span class="string">Example image</span>](<span class="link">/public/img/rene.jpg</span>)</span><br></pre></td></tr></table></figure><p>And the effect is like <a href="https://kimi.ai/">Visit Kimi</a><br>and image is like <img src="/../img/rene.jpg" alt="Example image"></p><ul><li><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; This is a refer text</span></span><br></pre></td></tr></table></figure><p>The effect is like the referred file is below. </p><blockquote><p>Referred articles. </p></blockquote><ul><li><h3 id="Divided-Line"><a href="#Divided-Line" class="headerlink" title="Divided Line"></a>Divided Line</h3></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;<span class="strong">__<span class="emphasis">_&#x27; is a horizon line.</span></span></span><br></pre></td></tr></table></figure><p>Text up</p><hr><p>Text down</p><ul><li><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3></li></ul><table><thead><tr><th>col 1</th><th>col 2</th></tr></thead><tbody><tr><td>content 1</td><td>content 2</td></tr></tbody></table><p>The code is like </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| col 1     | col 2     |</span><br><span class="line">|-----------|-----------|</span><br><span class="line">| content 1 | content 2 |</span><br></pre></td></tr></table></figure><h2 id="More-fancy-style"><a href="#More-fancy-style" class="headerlink" title="More fancy style"></a><em><strong>More fancy style</strong></em></h2><p>The most used Markdown format is all above, but you can achieve more fancy style if you want by writing html as Markdown file support this HTML grammar.</p><p>And using HTML, you can easily change fonts’ size, color, and many different style which Markdown can’t realize.</p><h3 id="For-examples"><a href="#For-examples" class="headerlink" title="For examples"></a><em><strong>For examples</strong></em></h3><p>If you want change font size of specific word between a sentence like ‘This is the <span style="font-size: 24px">Large Word</span> in a sentence.’</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 24pt; color: #00c4b6; background-color: white;&quot;</span>&gt;</span>Large Word<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Similarly, the style contain many different attributes like ‘font-size’, ‘color’, ‘background-color’ and etc.</p><p><span style="background-color: white; font-size: 20pt; color: #00c4b6">This is an example</span></p><h2 id="Latex-equation"><a href="#Latex-equation" class="headerlink" title="Latex equation"></a><em><strong>Latex equation</strong></em></h2><p>When people want to write equations or some math symbols they may get mad due to Markdown being really pool at this point. On the other side, Latex, another edition tool, is especially good at math equation edition.</p><h3 id="For-examples-1"><a href="#For-examples-1" class="headerlink" title="For examples"></a><em><strong>For examples</strong></em></h3><p>If you want inset a equation to support your theory then you can write<br>$$a + b &#x3D; c$$<br>by </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$your equation$$</span><br></pre></td></tr></table></figure><p>Also you can write Latex symbol or command between two ‘$$’.</p><p>For an example, you can write fraction by using \frac{}{}<br>$$F_{s} &#x3D; \frac{1}{T_{sample}}$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> file edition </tag>
            
            <tag> quick learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/12/hello-world/"/>
      <url>/2024/11/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
